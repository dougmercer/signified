{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Signified","text":"<p>A Python library for reactive programming (with kind-of working type narrowing).</p>"},{"location":"#quickstart","title":"Quickstart","text":"<pre><code>pip install signified\n</code></pre>"},{"location":"#why-care","title":"Why Care?","text":"<p><code>signified</code> is built around two core types:</p> <ul> <li><code>Signal</code>: mutable reactive state</li> <li><code>Computed</code>: derived reactive state</li> </ul> <p>If you update a <code>Signal</code>, dependent <code>Computed</code> values update automatically.</p> <p><code>Signal</code> and <code>Computed</code> follow both the <code>Observer</code> and <code>Observable</code> design patterns:</p> <ul> <li>reactive values can subscribe to upstream values</li> <li>upstream changes notify and propagate through dependent computations</li> </ul> <p>That allows you to write declarative expressions that stay up-to-date, even as underlying values change:</p> <pre><code>from signified import Signal\n\nx = Signal(3)\nx_squared = x ** 2\n\nprint(x_squared.value)  # 9\nx.value = 10\nprint(x_squared.value)  # 100\n</code></pre> <p>Above, we used <code>signified</code>'s rich set of overloaded operators build a <code>Computed</code> object on-the-fly.</p> <p>Alternatively, you can accomplish the same thing with <code>@computed</code>:</p> <pre><code>from signified import Signal, computed\n\n@computed\ndef power(base, exponent):\n    return base ** exponent\n\nx = Signal(3)\nx_squared = power(x, 2)\n\nprint(x_squared.value)  # 9\nx.value = 10\nprint(x_squared.value)  # 100\n</code></pre>"},{"location":"#mental-model","title":"Mental Model","text":"<ol> <li>Wrap changing data in <code>Signal</code>.</li> <li>Build derived values with overloaded Python operators or <code>@computed</code>.</li> <li>Read reactive outputs from <code>.value</code>.</li> <li>Update the <code>.value</code> of <code>Signal</code>s to trigger updates.</li> </ol>"},{"location":"#ready-to-learn-more","title":"Ready to learn more?","text":"<ul> <li>Read this first: Usage Guide</li> <li>Full API docs: Core API</li> <li>Quick look at avilable operators: Magic Methods and Operators</li> <li>Extending <code>signified</code> with plugins: Plugins</li> </ul>"},{"location":"api/","title":"Core","text":""},{"location":"api/#signified.core","title":"signified.core","text":"<p>Core reactive programming functionality.</p>"},{"location":"api/#signified.core.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['Observer', 'ReactiveMixIn', 'Variable', 'Signal', 'Computed', 'computed', 'unref', 'has_value', 'deep_unref', 'reactive_method', 'as_signal']\n</code></pre>"},{"location":"api/#signified.core.InstanceMethod","title":"InstanceMethod","text":"<pre><code>InstanceMethod = Callable[Concatenate[Any, P], T]\n</code></pre>"},{"location":"api/#signified.core.ReactiveMethod","title":"ReactiveMethod","text":"<pre><code>ReactiveMethod = Callable[Concatenate[Any, P], Computed[T]]\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn","title":"ReactiveMixIn","text":"<p>Methods for easily creating reactive values.</p>"},{"location":"api/#signified.core.ReactiveMixIn.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>The current value of the reactive object.</p>"},{"location":"api/#signified.core.ReactiveMixIn.notify","title":"notify","text":"<pre><code>notify()\n</code></pre> <p>Notify all observers by calling their <code>update</code> method.</p>"},{"location":"api/#signified.core.ReactiveMixIn.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: Literal['value', '_value']) -&gt; T\n</code></pre><pre><code>__getattr__(name: str) -&gt; Computed[Any]\n</code></pre> <pre><code>__getattr__(name)\n</code></pre> <p>Create a reactive value for retrieving an attribute from <code>self.value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Type Description <code>Union[T, Computed[Any]]</code> <p>A reactive value for the attribute access.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist.</p> Note <p>Type inference is poor whenever <code>__getattr__</code> is used.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.name\n&gt;&gt;&gt; result.value\n'Alice'\n&gt;&gt;&gt; s.value = Person(\"Bob\")\n&gt;&gt;&gt; result.value\n'Bob'\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Create a reactive value for calling <code>self.value(*args, **kwargs)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the callable value.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the callable value.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Computed[R]</code> <p>A reactive value for the function call.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not callable.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n...     def greet(self):\n...         return f\"Hi, I'm {self.name}!\"\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.greet()\n&gt;&gt;&gt; result.value\n\"Hi, I'm Alice!\"\n&gt;&gt;&gt; s.name = \"Bob\"\n&gt;&gt;&gt; result.value\n\"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Computed[float]\n</code></pre><pre><code>__abs__() -&gt; Computed[int]\n</code></pre><pre><code>__abs__() -&gt; Computed[T]\n</code></pre> <pre><code>__abs__()\n</code></pre> <p>Return a reactive value for the absolute value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[float] | Computed[int]</code> <p>A reactive value for <code>abs(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = abs(s)\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = -10\n&gt;&gt;&gt; result.value\n10\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.as_bool","title":"as_bool","text":"<pre><code>as_bool()\n</code></pre> <p>Return a reactive value for the boolean value of <code>self</code>.</p> Note <p><code>__bool__</code> cannot be implemented to return a non-<code>bool</code>, so it is provided as a method.</p> <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>bool(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(1)\n&gt;&gt;&gt; result = s.as_bool()\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 0\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return a string of the current value.</p> Note <p>This is not reactive.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of <code>self.value</code>.</p>"},{"location":"api/#signified.core.ReactiveMixIn.__round__","title":"__round__","text":"<pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[float]\n</code></pre><pre><code>__round__(ndigits: int | None = None) -&gt; Computed[int] | Computed[float]\n</code></pre> <pre><code>__round__(ndigits=None)\n</code></pre> <p>Return a reactive value for the rounded value of self.</p> <p>Parameters:</p> Name Type Description Default <code>ndigits</code> <code>int | None</code> <p>Number of decimal places to round to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Computed[int] | Computed[float]</code> <p>A reactive value for <code>round(self.value, ndigits)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3.14159)\n&gt;&gt;&gt; result = round(s, 2)\n&gt;&gt;&gt; result.value\n3.14\n&gt;&gt;&gt; s.value = 2.71828\n&gt;&gt;&gt; result.value\n2.72\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__ceil__","title":"__ceil__","text":"<pre><code>__ceil__()\n</code></pre> <p>Return a reactive value for the ceiling of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.ceil(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import ceil\n&gt;&gt;&gt; s = Signal(3.14)\n&gt;&gt;&gt; result = ceil(s)\n&gt;&gt;&gt; result.value\n4\n&gt;&gt;&gt; s.value = 2.01\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__floor__","title":"__floor__","text":"<pre><code>__floor__()\n</code></pre> <p>Return a reactive value for the floor of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.floor(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import floor\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = floor(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4.01\n&gt;&gt;&gt; result.value\n4\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__invert__","title":"__invert__","text":"<pre><code>__invert__() -&gt; Computed[int]\n</code></pre><pre><code>__invert__() -&gt; Computed[T]\n</code></pre> <pre><code>__invert__()\n</code></pre> <p>Return a reactive value for the bitwise inversion of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>~self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = ~s\n&gt;&gt;&gt; result.value\n-6\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Computed[int]\n</code></pre><pre><code>__neg__() -&gt; Computed[T]\n</code></pre> <pre><code>__neg__()\n</code></pre> <p>Return a reactive value for the negation of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>-self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = -s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Computed[int]\n</code></pre><pre><code>__pos__() -&gt; Computed[T]\n</code></pre> <pre><code>__pos__()\n</code></pre> <p>Return a reactive value for the positive of self.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>+self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = +s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__trunc__","title":"__trunc__","text":"<pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[T]\n</code></pre> <pre><code>__trunc__()\n</code></pre> <p>Return a reactive value for the truncated value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>math.trunc(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import trunc\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = trunc(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = -4.01\n&gt;&gt;&gt; result.value\n-4\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__add__","title":"__add__","text":"<pre><code>__add__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[Y]) -&gt; Computed[R]\n</code></pre><pre><code>__add__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s + 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__and__","title":"__and__","text":"<pre><code>__and__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &amp; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s &amp; False\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.contains","title":"contains","text":"<pre><code>contains(other)\n</code></pre> <p>Return a reactive value for whether <code>other</code> is in <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to check for containment.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>other in self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n&gt;&gt;&gt; result = s.contains(3)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = [5, 6, 7, 8]\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__divmod__","title":"__divmod__","text":"<pre><code>__divmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__divmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(self.value, other)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = divmod(s, 3)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 20\n&gt;&gt;&gt; result.value\n(6, 2)\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.is_not","title":"is_not","text":"<pre><code>is_not(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value is not other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; other = None\n&gt;&gt;&gt; result = s.is_not(other)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = None\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.eq","title":"eq","text":"<pre><code>eq(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> equals other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value == other.</p> Note <p>We can't overload <code>__eq__</code> because it interferes with basic Python operations.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s.eq(10)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__floordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__floordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>self</code> by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for self.value // other.value.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s // 3\n&gt;&gt;&gt; result.value\n6\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\n8\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__ge__","title":"__ge__","text":"<pre><code>__ge__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt;= other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__gt__","title":"__gt__","text":"<pre><code>__gt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt; other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt; 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__le__","title":"__le__","text":"<pre><code>__le__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than or equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt;= other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__lt__","title":"__lt__","text":"<pre><code>__lt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt; other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt; 10\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__lshift__","title":"__lshift__","text":"<pre><code>__lshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> left-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &lt;&lt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(8)\n&gt;&gt;&gt; result = s &lt;&lt; 2\n&gt;&gt;&gt; result.value\n32\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__matmul__","title":"__matmul__","text":"<pre><code>__matmul__(other)\n</code></pre> <p>Return a reactive value for the matrix multiplication of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value @ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = Signal(np.array([1, 2]))\n&gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; result.value\narray([ 7, 10])\n&gt;&gt;&gt; s.value = np.array([2, 3])\n&gt;&gt;&gt; result.value\narray([11, 16])\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__mod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mod__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> modulo <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value % other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(17)\n&gt;&gt;&gt; result = s % 5\n&gt;&gt;&gt; result.value\n2\n&gt;&gt;&gt; s.value = 23\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__mul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__mul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = s * 3\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__ne__","title":"__ne__","text":"<pre><code>__ne__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value != other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s != 5\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = s | True\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> right-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &gt;&gt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(32)\n&gt;&gt;&gt; result = s &gt;&gt; 2\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 24\n&gt;&gt;&gt; result.value\n6\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__pow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__pow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = s ** 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value - other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s - 3\n&gt;&gt;&gt; result.value\n7\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__truediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s / 4\n&gt;&gt;&gt; result.value\n5.0\n&gt;&gt;&gt; s.value = 30\n&gt;&gt;&gt; result.value\n7.5\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__xor__","title":"__xor__","text":"<pre><code>__xor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s ^ False\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__radd__(other: HasValue[_SupportsAdd[T, R]]) -&gt; Computed[R]\n</code></pre><pre><code>__radd__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__radd__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = 3 + s\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rand__","title":"__rand__","text":"<pre><code>__rand__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value and other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False &amp; s\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rdivmod__","title":"__rdivmod__","text":"<pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[bool]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__rdivmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(other, self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = divmod(10, s)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n(2, 2)\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rfloordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rfloordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>other</code> by <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value // self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 // s\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rmod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmod__(other)\n</code></pre> <p>Return a reactive value for <code>other</code> modulo <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The dividend.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value % self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 % s\n&gt;&gt;&gt; result.value\n1\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__rmul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = 3 * s\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__ror__","title":"__ror__","text":"<pre><code>__ror__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = True | s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rpow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rpow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The base.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 3 ** s\n&gt;&gt;&gt; result.value\n9\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract from.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value - self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = 15 - s\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n0\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rtruediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 30 / s\n&gt;&gt;&gt; result.value\n15.0\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n10.0\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__rxor__","title":"__rxor__","text":"<pre><code>__rxor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False ^ s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: slice) -&gt; Computed[list[V]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[tuple[V, ...]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__getitem__(key)\n</code></pre> <p>Return a reactive value for the item or slice of <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value[key]</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n&gt;&gt;&gt; result = s[2]\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n&gt;&gt;&gt; result.value\n30\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Set an attribute on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the attribute via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even if one of its attributes changed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <pre><code>    &gt;&gt;&gt; class Person:\n    ...    def __init__(self, name: str):\n    ...        self.name = name\n    ...    def greet(self) -&gt; str:\n    ...        return f\"Hi, I'm {self.name}!\"\n    &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n    &gt;&gt;&gt; result = s.greet()\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Alice!\"\n    &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.ReactiveMixIn.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set an item on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the item via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even an element of the object is changed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key to change.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <p>```py</p> <p>s = Signal([1, 2, 3]) result = computed(sum)(s) result.value 6 s[1] = 4 result.value 8</p>"},{"location":"api/#signified.core.ReactiveMixIn.where","title":"where","text":"<pre><code>where(a, b)\n</code></pre> <p>Return a reactive value for <code>a</code> if <code>self</code> is <code>True</code>, else <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>HasValue[A]</code> <p>The value to return if <code>self</code> is <code>True</code>.</p> required <code>b</code> <code>HasValue[B]</code> <p>The value to return if <code>self</code> is <code>False</code>.</p> required <p>Returns:</p> Type Description <code>Computed[A | B]</code> <p>A reactive value for <code>a if self.value else b</code>.</p> Example <pre><code>&gt;&gt;&gt; condition = Signal(True)\n&gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n&gt;&gt;&gt; result.value\n'Yes'\n&gt;&gt;&gt; condition.value = False\n&gt;&gt;&gt; result.value\n'No'\n</code></pre>"},{"location":"api/#signified.core.Observer","title":"Observer","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"api/#signified.core.Observer.update","title":"update","text":"<pre><code>update()\n</code></pre>"},{"location":"api/#signified.core.Variable","title":"Variable","text":"<p>               Bases: <code>ABC</code>, <code>ReactiveMixIn[T]</code></p> <p>An abstract base class for reactive values.</p> <p>A reactive value is an object that can be observed by observer for changes and can notify observers when its value changes. This class implements both the observer and observable patterns.</p> <p>This class implements both the observer and observable pattern.</p> <p>Subclasses should implement the <code>update</code> method.</p> <p>Attributes:</p> Name Type Description <code>_observers</code> <code>list[Observer]</code> <p>List of observers subscribed to this variable.</p>"},{"location":"api/#signified.core.Variable.__slots__","title":"__slots__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__slots__ = ['_observers', '__name', '__weakref__']\n</code></pre>"},{"location":"api/#signified.core.Variable.__name","title":"__name  <code>instance-attribute</code>","text":"<pre><code>__name = ''\n</code></pre>"},{"location":"api/#signified.core.Variable.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>The current value of the reactive object.</p>"},{"location":"api/#signified.core.Variable.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> <p>Initialize the variable.</p>"},{"location":"api/#signified.core.Variable.subscribe","title":"subscribe","text":"<pre><code>subscribe(observer)\n</code></pre> <p>Subscribe an observer to this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to subscribe.</p> required"},{"location":"api/#signified.core.Variable.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(observer)\n</code></pre> <p>Unsubscribe an observer from this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to unsubscribe.</p> required"},{"location":"api/#signified.core.Variable.observe","title":"observe","text":"<pre><code>observe(items)\n</code></pre> <p>Subscribe the observer (<code>self</code>) to all items that are Observable.</p> <p>This method handles arbitrarily nested iterables.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item, an iterable, or a nested structure of items to potentially subscribe to.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p>"},{"location":"api/#signified.core.Variable.unobserve","title":"unobserve","text":"<pre><code>unobserve(items)\n</code></pre> <p>Unsubscribe the observer (<code>self</code>) from all items that are Observable.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item or an iterable of items to potentially unsubscribe from.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p>"},{"location":"api/#signified.core.Variable.notify","title":"notify","text":"<pre><code>notify()\n</code></pre> <p>Notify all observers by calling their update method.</p>"},{"location":"api/#signified.core.Variable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Represent the object in a way that shows the inner value.</p>"},{"location":"api/#signified.core.Variable.update","title":"update  <code>abstractmethod</code>","text":"<pre><code>update()\n</code></pre> <p>Update method to be overridden by subclasses.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not overridden by a subclass.</p>"},{"location":"api/#signified.core.Variable.add_name","title":"add_name","text":"<pre><code>add_name(name)\n</code></pre>"},{"location":"api/#signified.core.Variable.__format__","title":"__format__","text":"<pre><code>__format__(format_spec)\n</code></pre> <p>Format the variable with custom display options.</p> <p>Format options: :n  - just the name (or type+id if unnamed) :d  - full debug info empty - just the value in brackets (default)</p>"},{"location":"api/#signified.core.Variable.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: Literal['value', '_value']) -&gt; T\n</code></pre><pre><code>__getattr__(name: str) -&gt; Computed[Any]\n</code></pre> <pre><code>__getattr__(name)\n</code></pre> <p>Create a reactive value for retrieving an attribute from <code>self.value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Type Description <code>Union[T, Computed[Any]]</code> <p>A reactive value for the attribute access.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist.</p> Note <p>Type inference is poor whenever <code>__getattr__</code> is used.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.name\n&gt;&gt;&gt; result.value\n'Alice'\n&gt;&gt;&gt; s.value = Person(\"Bob\")\n&gt;&gt;&gt; result.value\n'Bob'\n</code></pre>"},{"location":"api/#signified.core.Variable.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Create a reactive value for calling <code>self.value(*args, **kwargs)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the callable value.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the callable value.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Computed[R]</code> <p>A reactive value for the function call.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not callable.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n...     def greet(self):\n...         return f\"Hi, I'm {self.name}!\"\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.greet()\n&gt;&gt;&gt; result.value\n\"Hi, I'm Alice!\"\n&gt;&gt;&gt; s.name = \"Bob\"\n&gt;&gt;&gt; result.value\n\"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.Variable.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Computed[float]\n</code></pre><pre><code>__abs__() -&gt; Computed[int]\n</code></pre><pre><code>__abs__() -&gt; Computed[T]\n</code></pre> <pre><code>__abs__()\n</code></pre> <p>Return a reactive value for the absolute value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[float] | Computed[int]</code> <p>A reactive value for <code>abs(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = abs(s)\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = -10\n&gt;&gt;&gt; result.value\n10\n</code></pre>"},{"location":"api/#signified.core.Variable.as_bool","title":"as_bool","text":"<pre><code>as_bool()\n</code></pre> <p>Return a reactive value for the boolean value of <code>self</code>.</p> Note <p><code>__bool__</code> cannot be implemented to return a non-<code>bool</code>, so it is provided as a method.</p> <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>bool(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(1)\n&gt;&gt;&gt; result = s.as_bool()\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 0\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return a string of the current value.</p> Note <p>This is not reactive.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of <code>self.value</code>.</p>"},{"location":"api/#signified.core.Variable.__round__","title":"__round__","text":"<pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[float]\n</code></pre><pre><code>__round__(ndigits: int | None = None) -&gt; Computed[int] | Computed[float]\n</code></pre> <pre><code>__round__(ndigits=None)\n</code></pre> <p>Return a reactive value for the rounded value of self.</p> <p>Parameters:</p> Name Type Description Default <code>ndigits</code> <code>int | None</code> <p>Number of decimal places to round to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Computed[int] | Computed[float]</code> <p>A reactive value for <code>round(self.value, ndigits)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3.14159)\n&gt;&gt;&gt; result = round(s, 2)\n&gt;&gt;&gt; result.value\n3.14\n&gt;&gt;&gt; s.value = 2.71828\n&gt;&gt;&gt; result.value\n2.72\n</code></pre>"},{"location":"api/#signified.core.Variable.__ceil__","title":"__ceil__","text":"<pre><code>__ceil__()\n</code></pre> <p>Return a reactive value for the ceiling of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.ceil(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import ceil\n&gt;&gt;&gt; s = Signal(3.14)\n&gt;&gt;&gt; result = ceil(s)\n&gt;&gt;&gt; result.value\n4\n&gt;&gt;&gt; s.value = 2.01\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Variable.__floor__","title":"__floor__","text":"<pre><code>__floor__()\n</code></pre> <p>Return a reactive value for the floor of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.floor(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import floor\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = floor(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4.01\n&gt;&gt;&gt; result.value\n4\n</code></pre>"},{"location":"api/#signified.core.Variable.__invert__","title":"__invert__","text":"<pre><code>__invert__() -&gt; Computed[int]\n</code></pre><pre><code>__invert__() -&gt; Computed[T]\n</code></pre> <pre><code>__invert__()\n</code></pre> <p>Return a reactive value for the bitwise inversion of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>~self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = ~s\n&gt;&gt;&gt; result.value\n-6\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Variable.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Computed[int]\n</code></pre><pre><code>__neg__() -&gt; Computed[T]\n</code></pre> <pre><code>__neg__()\n</code></pre> <p>Return a reactive value for the negation of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>-self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = -s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Variable.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Computed[int]\n</code></pre><pre><code>__pos__() -&gt; Computed[T]\n</code></pre> <pre><code>__pos__()\n</code></pre> <p>Return a reactive value for the positive of self.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>+self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = +s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Variable.__trunc__","title":"__trunc__","text":"<pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[T]\n</code></pre> <pre><code>__trunc__()\n</code></pre> <p>Return a reactive value for the truncated value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>math.trunc(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import trunc\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = trunc(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = -4.01\n&gt;&gt;&gt; result.value\n-4\n</code></pre>"},{"location":"api/#signified.core.Variable.__add__","title":"__add__","text":"<pre><code>__add__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[Y]) -&gt; Computed[R]\n</code></pre><pre><code>__add__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s + 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.Variable.__and__","title":"__and__","text":"<pre><code>__and__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &amp; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s &amp; False\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.contains","title":"contains","text":"<pre><code>contains(other)\n</code></pre> <p>Return a reactive value for whether <code>other</code> is in <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to check for containment.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>other in self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n&gt;&gt;&gt; result = s.contains(3)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = [5, 6, 7, 8]\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__divmod__","title":"__divmod__","text":"<pre><code>__divmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__divmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(self.value, other)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = divmod(s, 3)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 20\n&gt;&gt;&gt; result.value\n(6, 2)\n</code></pre>"},{"location":"api/#signified.core.Variable.is_not","title":"is_not","text":"<pre><code>is_not(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value is not other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; other = None\n&gt;&gt;&gt; result = s.is_not(other)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = None\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.eq","title":"eq","text":"<pre><code>eq(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> equals other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value == other.</p> Note <p>We can't overload <code>__eq__</code> because it interferes with basic Python operations.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s.eq(10)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__floordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__floordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>self</code> by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for self.value // other.value.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s // 3\n&gt;&gt;&gt; result.value\n6\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\n8\n</code></pre>"},{"location":"api/#signified.core.Variable.__ge__","title":"__ge__","text":"<pre><code>__ge__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt;= other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__gt__","title":"__gt__","text":"<pre><code>__gt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt; other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt; 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__le__","title":"__le__","text":"<pre><code>__le__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than or equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt;= other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__lt__","title":"__lt__","text":"<pre><code>__lt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt; other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt; 10\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__lshift__","title":"__lshift__","text":"<pre><code>__lshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> left-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &lt;&lt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(8)\n&gt;&gt;&gt; result = s &lt;&lt; 2\n&gt;&gt;&gt; result.value\n32\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.Variable.__matmul__","title":"__matmul__","text":"<pre><code>__matmul__(other)\n</code></pre> <p>Return a reactive value for the matrix multiplication of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value @ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = Signal(np.array([1, 2]))\n&gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; result.value\narray([ 7, 10])\n&gt;&gt;&gt; s.value = np.array([2, 3])\n&gt;&gt;&gt; result.value\narray([11, 16])\n</code></pre>"},{"location":"api/#signified.core.Variable.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__mod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mod__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> modulo <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value % other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(17)\n&gt;&gt;&gt; result = s % 5\n&gt;&gt;&gt; result.value\n2\n&gt;&gt;&gt; s.value = 23\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Variable.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__mul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__mul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = s * 3\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.Variable.__ne__","title":"__ne__","text":"<pre><code>__ne__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value != other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s != 5\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Variable.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = s | True\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Variable.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> right-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &gt;&gt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(32)\n&gt;&gt;&gt; result = s &gt;&gt; 2\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 24\n&gt;&gt;&gt; result.value\n6\n</code></pre>"},{"location":"api/#signified.core.Variable.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__pow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__pow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = s ** 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.Variable.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value - other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s - 3\n&gt;&gt;&gt; result.value\n7\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.Variable.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__truediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s / 4\n&gt;&gt;&gt; result.value\n5.0\n&gt;&gt;&gt; s.value = 30\n&gt;&gt;&gt; result.value\n7.5\n</code></pre>"},{"location":"api/#signified.core.Variable.__xor__","title":"__xor__","text":"<pre><code>__xor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s ^ False\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__radd__(other: HasValue[_SupportsAdd[T, R]]) -&gt; Computed[R]\n</code></pre><pre><code>__radd__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__radd__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = 3 + s\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.Variable.__rand__","title":"__rand__","text":"<pre><code>__rand__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value and other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False &amp; s\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__rdivmod__","title":"__rdivmod__","text":"<pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[bool]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__rdivmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(other, self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = divmod(10, s)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n(2, 2)\n</code></pre>"},{"location":"api/#signified.core.Variable.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rfloordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rfloordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>other</code> by <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value // self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 // s\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Variable.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rmod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmod__(other)\n</code></pre> <p>Return a reactive value for <code>other</code> modulo <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The dividend.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value % self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 % s\n&gt;&gt;&gt; result.value\n1\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Variable.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__rmul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = 3 * s\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.Variable.__ror__","title":"__ror__","text":"<pre><code>__ror__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = True | s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Variable.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rpow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rpow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The base.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 3 ** s\n&gt;&gt;&gt; result.value\n9\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.Variable.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract from.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value - self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = 15 - s\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n0\n</code></pre>"},{"location":"api/#signified.core.Variable.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rtruediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 30 / s\n&gt;&gt;&gt; result.value\n15.0\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n10.0\n</code></pre>"},{"location":"api/#signified.core.Variable.__rxor__","title":"__rxor__","text":"<pre><code>__rxor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False ^ s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Variable.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: slice) -&gt; Computed[list[V]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[tuple[V, ...]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__getitem__(key)\n</code></pre> <p>Return a reactive value for the item or slice of <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value[key]</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n&gt;&gt;&gt; result = s[2]\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n&gt;&gt;&gt; result.value\n30\n</code></pre>"},{"location":"api/#signified.core.Variable.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Set an attribute on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the attribute via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even if one of its attributes changed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <pre><code>    &gt;&gt;&gt; class Person:\n    ...    def __init__(self, name: str):\n    ...        self.name = name\n    ...    def greet(self) -&gt; str:\n    ...        return f\"Hi, I'm {self.name}!\"\n    &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n    &gt;&gt;&gt; result = s.greet()\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Alice!\"\n    &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.Variable.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set an item on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the item via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even an element of the object is changed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key to change.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <p>```py</p> <p>s = Signal([1, 2, 3]) result = computed(sum)(s) result.value 6 s[1] = 4 result.value 8</p>"},{"location":"api/#signified.core.Variable.where","title":"where","text":"<pre><code>where(a, b)\n</code></pre> <p>Return a reactive value for <code>a</code> if <code>self</code> is <code>True</code>, else <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>HasValue[A]</code> <p>The value to return if <code>self</code> is <code>True</code>.</p> required <code>b</code> <code>HasValue[B]</code> <p>The value to return if <code>self</code> is <code>False</code>.</p> required <p>Returns:</p> Type Description <code>Computed[A | B]</code> <p>A reactive value for <code>a if self.value else b</code>.</p> Example <pre><code>&gt;&gt;&gt; condition = Signal(True)\n&gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n&gt;&gt;&gt; result.value\n'Yes'\n&gt;&gt;&gt; condition.value = False\n&gt;&gt;&gt; result.value\n'No'\n</code></pre>"},{"location":"api/#signified.core.Signal","title":"Signal","text":"<p>               Bases: <code>Variable[T]</code></p> <p>Mutable source-of-truth reactive value.</p> <p><code>Signal</code> stores a value and notifies subscribers when that value changes. It is typically used for application state that should be observed by derived :class:<code>Computed</code> values.</p> <p>The <code>value</code> property is read/write: - reading <code>value</code> returns the resolved plain value - assigning <code>value</code> updates dependencies and notifies observers when the   value changed</p> <p>Signals can also proxy mutation operations (for example <code>__setattr__</code> and <code>__setitem__</code>) so in-place updates on wrapped objects can still trigger reactivity.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>HasValue[T]</code> <p>Initial value to wrap. May be plain or reactive.</p> required Example <pre><code>&gt;&gt;&gt; count = Signal(1)\n&gt;&gt;&gt; doubled = count * 2\n&gt;&gt;&gt; doubled.value\n2\n&gt;&gt;&gt; count.value = 3\n&gt;&gt;&gt; doubled.value\n6\n</code></pre>"},{"location":"api/#signified.core.Signal.__slots__","title":"__slots__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__slots__ = ['_value']\n</code></pre>"},{"location":"api/#signified.core.Signal.value","title":"value  <code>property</code> <code>writable</code>","text":"<pre><code>value\n</code></pre> <p>Get or set the current value.</p>"},{"location":"api/#signified.core.Signal.__name","title":"__name  <code>instance-attribute</code>","text":"<pre><code>__name = ''\n</code></pre>"},{"location":"api/#signified.core.Signal.__init__","title":"__init__","text":"<pre><code>__init__(value: ReactiveValue[T]) -&gt; None\n</code></pre><pre><code>__init__(value: T) -&gt; None\n</code></pre> <pre><code>__init__(value)\n</code></pre>"},{"location":"api/#signified.core.Signal.at","title":"at","text":"<pre><code>at(value)\n</code></pre> <p>Temporarily set the signal to a given value within a context.</p>"},{"location":"api/#signified.core.Signal.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the signal and notify subscribers.</p>"},{"location":"api/#signified.core.Signal.notify","title":"notify","text":"<pre><code>notify()\n</code></pre> <p>Notify all observers by calling their update method.</p>"},{"location":"api/#signified.core.Signal.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: Literal['value', '_value']) -&gt; T\n</code></pre><pre><code>__getattr__(name: str) -&gt; Computed[Any]\n</code></pre> <pre><code>__getattr__(name)\n</code></pre> <p>Create a reactive value for retrieving an attribute from <code>self.value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Type Description <code>Union[T, Computed[Any]]</code> <p>A reactive value for the attribute access.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist.</p> Note <p>Type inference is poor whenever <code>__getattr__</code> is used.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.name\n&gt;&gt;&gt; result.value\n'Alice'\n&gt;&gt;&gt; s.value = Person(\"Bob\")\n&gt;&gt;&gt; result.value\n'Bob'\n</code></pre>"},{"location":"api/#signified.core.Signal.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Create a reactive value for calling <code>self.value(*args, **kwargs)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the callable value.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the callable value.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Computed[R]</code> <p>A reactive value for the function call.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not callable.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n...     def greet(self):\n...         return f\"Hi, I'm {self.name}!\"\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.greet()\n&gt;&gt;&gt; result.value\n\"Hi, I'm Alice!\"\n&gt;&gt;&gt; s.name = \"Bob\"\n&gt;&gt;&gt; result.value\n\"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.Signal.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Computed[float]\n</code></pre><pre><code>__abs__() -&gt; Computed[int]\n</code></pre><pre><code>__abs__() -&gt; Computed[T]\n</code></pre> <pre><code>__abs__()\n</code></pre> <p>Return a reactive value for the absolute value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[float] | Computed[int]</code> <p>A reactive value for <code>abs(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = abs(s)\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = -10\n&gt;&gt;&gt; result.value\n10\n</code></pre>"},{"location":"api/#signified.core.Signal.as_bool","title":"as_bool","text":"<pre><code>as_bool()\n</code></pre> <p>Return a reactive value for the boolean value of <code>self</code>.</p> Note <p><code>__bool__</code> cannot be implemented to return a non-<code>bool</code>, so it is provided as a method.</p> <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>bool(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(1)\n&gt;&gt;&gt; result = s.as_bool()\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 0\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return a string of the current value.</p> Note <p>This is not reactive.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of <code>self.value</code>.</p>"},{"location":"api/#signified.core.Signal.__round__","title":"__round__","text":"<pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[float]\n</code></pre><pre><code>__round__(ndigits: int | None = None) -&gt; Computed[int] | Computed[float]\n</code></pre> <pre><code>__round__(ndigits=None)\n</code></pre> <p>Return a reactive value for the rounded value of self.</p> <p>Parameters:</p> Name Type Description Default <code>ndigits</code> <code>int | None</code> <p>Number of decimal places to round to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Computed[int] | Computed[float]</code> <p>A reactive value for <code>round(self.value, ndigits)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3.14159)\n&gt;&gt;&gt; result = round(s, 2)\n&gt;&gt;&gt; result.value\n3.14\n&gt;&gt;&gt; s.value = 2.71828\n&gt;&gt;&gt; result.value\n2.72\n</code></pre>"},{"location":"api/#signified.core.Signal.__ceil__","title":"__ceil__","text":"<pre><code>__ceil__()\n</code></pre> <p>Return a reactive value for the ceiling of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.ceil(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import ceil\n&gt;&gt;&gt; s = Signal(3.14)\n&gt;&gt;&gt; result = ceil(s)\n&gt;&gt;&gt; result.value\n4\n&gt;&gt;&gt; s.value = 2.01\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Signal.__floor__","title":"__floor__","text":"<pre><code>__floor__()\n</code></pre> <p>Return a reactive value for the floor of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.floor(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import floor\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = floor(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4.01\n&gt;&gt;&gt; result.value\n4\n</code></pre>"},{"location":"api/#signified.core.Signal.__invert__","title":"__invert__","text":"<pre><code>__invert__() -&gt; Computed[int]\n</code></pre><pre><code>__invert__() -&gt; Computed[T]\n</code></pre> <pre><code>__invert__()\n</code></pre> <p>Return a reactive value for the bitwise inversion of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>~self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = ~s\n&gt;&gt;&gt; result.value\n-6\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Signal.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Computed[int]\n</code></pre><pre><code>__neg__() -&gt; Computed[T]\n</code></pre> <pre><code>__neg__()\n</code></pre> <p>Return a reactive value for the negation of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>-self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = -s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Signal.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Computed[int]\n</code></pre><pre><code>__pos__() -&gt; Computed[T]\n</code></pre> <pre><code>__pos__()\n</code></pre> <p>Return a reactive value for the positive of self.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>+self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = +s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Signal.__trunc__","title":"__trunc__","text":"<pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[T]\n</code></pre> <pre><code>__trunc__()\n</code></pre> <p>Return a reactive value for the truncated value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>math.trunc(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import trunc\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = trunc(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = -4.01\n&gt;&gt;&gt; result.value\n-4\n</code></pre>"},{"location":"api/#signified.core.Signal.__add__","title":"__add__","text":"<pre><code>__add__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[Y]) -&gt; Computed[R]\n</code></pre><pre><code>__add__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s + 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.Signal.__and__","title":"__and__","text":"<pre><code>__and__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &amp; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s &amp; False\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.contains","title":"contains","text":"<pre><code>contains(other)\n</code></pre> <p>Return a reactive value for whether <code>other</code> is in <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to check for containment.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>other in self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n&gt;&gt;&gt; result = s.contains(3)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = [5, 6, 7, 8]\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__divmod__","title":"__divmod__","text":"<pre><code>__divmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__divmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(self.value, other)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = divmod(s, 3)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 20\n&gt;&gt;&gt; result.value\n(6, 2)\n</code></pre>"},{"location":"api/#signified.core.Signal.is_not","title":"is_not","text":"<pre><code>is_not(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value is not other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; other = None\n&gt;&gt;&gt; result = s.is_not(other)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = None\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.eq","title":"eq","text":"<pre><code>eq(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> equals other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value == other.</p> Note <p>We can't overload <code>__eq__</code> because it interferes with basic Python operations.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s.eq(10)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__floordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__floordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>self</code> by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for self.value // other.value.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s // 3\n&gt;&gt;&gt; result.value\n6\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\n8\n</code></pre>"},{"location":"api/#signified.core.Signal.__ge__","title":"__ge__","text":"<pre><code>__ge__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt;= other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__gt__","title":"__gt__","text":"<pre><code>__gt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt; other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt; 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__le__","title":"__le__","text":"<pre><code>__le__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than or equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt;= other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__lt__","title":"__lt__","text":"<pre><code>__lt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt; other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt; 10\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__lshift__","title":"__lshift__","text":"<pre><code>__lshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> left-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &lt;&lt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(8)\n&gt;&gt;&gt; result = s &lt;&lt; 2\n&gt;&gt;&gt; result.value\n32\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.Signal.__matmul__","title":"__matmul__","text":"<pre><code>__matmul__(other)\n</code></pre> <p>Return a reactive value for the matrix multiplication of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value @ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = Signal(np.array([1, 2]))\n&gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; result.value\narray([ 7, 10])\n&gt;&gt;&gt; s.value = np.array([2, 3])\n&gt;&gt;&gt; result.value\narray([11, 16])\n</code></pre>"},{"location":"api/#signified.core.Signal.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__mod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mod__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> modulo <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value % other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(17)\n&gt;&gt;&gt; result = s % 5\n&gt;&gt;&gt; result.value\n2\n&gt;&gt;&gt; s.value = 23\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Signal.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__mul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__mul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = s * 3\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.Signal.__ne__","title":"__ne__","text":"<pre><code>__ne__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value != other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s != 5\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Signal.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = s | True\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Signal.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> right-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &gt;&gt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(32)\n&gt;&gt;&gt; result = s &gt;&gt; 2\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 24\n&gt;&gt;&gt; result.value\n6\n</code></pre>"},{"location":"api/#signified.core.Signal.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__pow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__pow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = s ** 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.Signal.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value - other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s - 3\n&gt;&gt;&gt; result.value\n7\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.Signal.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__truediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s / 4\n&gt;&gt;&gt; result.value\n5.0\n&gt;&gt;&gt; s.value = 30\n&gt;&gt;&gt; result.value\n7.5\n</code></pre>"},{"location":"api/#signified.core.Signal.__xor__","title":"__xor__","text":"<pre><code>__xor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s ^ False\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__radd__(other: HasValue[_SupportsAdd[T, R]]) -&gt; Computed[R]\n</code></pre><pre><code>__radd__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__radd__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = 3 + s\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.Signal.__rand__","title":"__rand__","text":"<pre><code>__rand__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value and other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False &amp; s\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__rdivmod__","title":"__rdivmod__","text":"<pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[bool]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__rdivmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(other, self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = divmod(10, s)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n(2, 2)\n</code></pre>"},{"location":"api/#signified.core.Signal.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rfloordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rfloordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>other</code> by <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value // self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 // s\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Signal.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rmod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmod__(other)\n</code></pre> <p>Return a reactive value for <code>other</code> modulo <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The dividend.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value % self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 % s\n&gt;&gt;&gt; result.value\n1\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Signal.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__rmul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = 3 * s\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.Signal.__ror__","title":"__ror__","text":"<pre><code>__ror__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = True | s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Signal.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rpow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rpow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The base.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 3 ** s\n&gt;&gt;&gt; result.value\n9\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.Signal.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract from.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value - self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = 15 - s\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n0\n</code></pre>"},{"location":"api/#signified.core.Signal.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rtruediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 30 / s\n&gt;&gt;&gt; result.value\n15.0\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n10.0\n</code></pre>"},{"location":"api/#signified.core.Signal.__rxor__","title":"__rxor__","text":"<pre><code>__rxor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False ^ s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Signal.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: slice) -&gt; Computed[list[V]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[tuple[V, ...]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__getitem__(key)\n</code></pre> <p>Return a reactive value for the item or slice of <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value[key]</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n&gt;&gt;&gt; result = s[2]\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n&gt;&gt;&gt; result.value\n30\n</code></pre>"},{"location":"api/#signified.core.Signal.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Set an attribute on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the attribute via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even if one of its attributes changed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <pre><code>    &gt;&gt;&gt; class Person:\n    ...    def __init__(self, name: str):\n    ...        self.name = name\n    ...    def greet(self) -&gt; str:\n    ...        return f\"Hi, I'm {self.name}!\"\n    &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n    &gt;&gt;&gt; result = s.greet()\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Alice!\"\n    &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.Signal.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set an item on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the item via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even an element of the object is changed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key to change.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <p>```py</p> <p>s = Signal([1, 2, 3]) result = computed(sum)(s) result.value 6 s[1] = 4 result.value 8</p>"},{"location":"api/#signified.core.Signal.where","title":"where","text":"<pre><code>where(a, b)\n</code></pre> <p>Return a reactive value for <code>a</code> if <code>self</code> is <code>True</code>, else <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>HasValue[A]</code> <p>The value to return if <code>self</code> is <code>True</code>.</p> required <code>b</code> <code>HasValue[B]</code> <p>The value to return if <code>self</code> is <code>False</code>.</p> required <p>Returns:</p> Type Description <code>Computed[A | B]</code> <p>A reactive value for <code>a if self.value else b</code>.</p> Example <pre><code>&gt;&gt;&gt; condition = Signal(True)\n&gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n&gt;&gt;&gt; result.value\n'Yes'\n&gt;&gt;&gt; condition.value = False\n&gt;&gt;&gt; result.value\n'No'\n</code></pre>"},{"location":"api/#signified.core.Signal.subscribe","title":"subscribe","text":"<pre><code>subscribe(observer)\n</code></pre> <p>Subscribe an observer to this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to subscribe.</p> required"},{"location":"api/#signified.core.Signal.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(observer)\n</code></pre> <p>Unsubscribe an observer from this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to unsubscribe.</p> required"},{"location":"api/#signified.core.Signal.observe","title":"observe","text":"<pre><code>observe(items)\n</code></pre> <p>Subscribe the observer (<code>self</code>) to all items that are Observable.</p> <p>This method handles arbitrarily nested iterables.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item, an iterable, or a nested structure of items to potentially subscribe to.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p>"},{"location":"api/#signified.core.Signal.unobserve","title":"unobserve","text":"<pre><code>unobserve(items)\n</code></pre> <p>Unsubscribe the observer (<code>self</code>) from all items that are Observable.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item or an iterable of items to potentially unsubscribe from.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p>"},{"location":"api/#signified.core.Signal.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Represent the object in a way that shows the inner value.</p>"},{"location":"api/#signified.core.Signal.add_name","title":"add_name","text":"<pre><code>add_name(name)\n</code></pre>"},{"location":"api/#signified.core.Signal.__format__","title":"__format__","text":"<pre><code>__format__(format_spec)\n</code></pre> <p>Format the variable with custom display options.</p> <p>Format options: :n  - just the name (or type+id if unnamed) :d  - full debug info empty - just the value in brackets (default)</p>"},{"location":"api/#signified.core.Computed","title":"Computed","text":"<p>               Bases: <code>Variable[T]</code></p> <p>Read-only reactive value derived from a computation.</p> <p><code>Computed</code> recalculates its value whenever one of its observed dependencies updates. In most usage, instances are created implicitly via :func:<code>computed</code>, operator overloads, or helper APIs such as :func:<code>reactive_method</code>.</p> <p>Unlike :class:<code>Signal</code>, <code>Computed.value</code> is read-only and is updated by re-running the stored function.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], T]</code> <p>Zero-argument function used to compute the current value.</p> required <code>dependencies</code> <code>Any</code> <p>Dependencies to observe. May be a single item or nested container structure.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; count = Signal(2)\n&gt;&gt;&gt; squared = Computed(lambda: count.value ** 2, dependencies=count)\n&gt;&gt;&gt; squared.value\n4\n&gt;&gt;&gt; count.value = 5\n&gt;&gt;&gt; squared.value\n25\n</code></pre>"},{"location":"api/#signified.core.Computed.__slots__","title":"__slots__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__slots__ = ['f', '_value']\n</code></pre>"},{"location":"api/#signified.core.Computed.f","title":"f  <code>instance-attribute</code>","text":"<pre><code>f = f\n</code></pre>"},{"location":"api/#signified.core.Computed.value","title":"value  <code>property</code>","text":"<pre><code>value\n</code></pre> <p>Get the current value.</p>"},{"location":"api/#signified.core.Computed.__name","title":"__name  <code>instance-attribute</code>","text":"<pre><code>__name = ''\n</code></pre>"},{"location":"api/#signified.core.Computed.__init__","title":"__init__","text":"<pre><code>__init__(f, dependencies=None)\n</code></pre>"},{"location":"api/#signified.core.Computed.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Update the value by re-evaluating the function.</p>"},{"location":"api/#signified.core.Computed.notify","title":"notify","text":"<pre><code>notify()\n</code></pre> <p>Notify all observers by calling their update method.</p>"},{"location":"api/#signified.core.Computed.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: Literal['value', '_value']) -&gt; T\n</code></pre><pre><code>__getattr__(name: str) -&gt; Computed[Any]\n</code></pre> <pre><code>__getattr__(name)\n</code></pre> <p>Create a reactive value for retrieving an attribute from <code>self.value</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Type Description <code>Union[T, Computed[Any]]</code> <p>A reactive value for the attribute access.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist.</p> Note <p>Type inference is poor whenever <code>__getattr__</code> is used.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.name\n&gt;&gt;&gt; result.value\n'Alice'\n&gt;&gt;&gt; s.value = Person(\"Bob\")\n&gt;&gt;&gt; result.value\n'Bob'\n</code></pre>"},{"location":"api/#signified.core.Computed.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Create a reactive value for calling <code>self.value(*args, **kwargs)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the callable value.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the callable value.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Computed[R]</code> <p>A reactive value for the function call.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not callable.</p> Example <pre><code>&gt;&gt;&gt; class Person:\n...     def __init__(self, name):\n...         self.name = name\n...     def greet(self):\n...         return f\"Hi, I'm {self.name}!\"\n&gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n&gt;&gt;&gt; result = s.greet()\n&gt;&gt;&gt; result.value\n\"Hi, I'm Alice!\"\n&gt;&gt;&gt; s.name = \"Bob\"\n&gt;&gt;&gt; result.value\n\"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.Computed.__abs__","title":"__abs__","text":"<pre><code>__abs__() -&gt; Computed[float]\n</code></pre><pre><code>__abs__() -&gt; Computed[int]\n</code></pre><pre><code>__abs__() -&gt; Computed[T]\n</code></pre> <pre><code>__abs__()\n</code></pre> <p>Return a reactive value for the absolute value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[float] | Computed[int]</code> <p>A reactive value for <code>abs(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = abs(s)\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = -10\n&gt;&gt;&gt; result.value\n10\n</code></pre>"},{"location":"api/#signified.core.Computed.as_bool","title":"as_bool","text":"<pre><code>as_bool()\n</code></pre> <p>Return a reactive value for the boolean value of <code>self</code>.</p> Note <p><code>__bool__</code> cannot be implemented to return a non-<code>bool</code>, so it is provided as a method.</p> <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>bool(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(1)\n&gt;&gt;&gt; result = s.as_bool()\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 0\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return a string of the current value.</p> Note <p>This is not reactive.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of <code>self.value</code>.</p>"},{"location":"api/#signified.core.Computed.__round__","title":"__round__","text":"<pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[int]\n</code></pre><pre><code>__round__() -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: None) -&gt; Computed[int]\n</code></pre><pre><code>__round__(ndigits: int) -&gt; Computed[float]\n</code></pre><pre><code>__round__(ndigits: int | None = None) -&gt; Computed[int] | Computed[float]\n</code></pre> <pre><code>__round__(ndigits=None)\n</code></pre> <p>Return a reactive value for the rounded value of self.</p> <p>Parameters:</p> Name Type Description Default <code>ndigits</code> <code>int | None</code> <p>Number of decimal places to round to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Computed[int] | Computed[float]</code> <p>A reactive value for <code>round(self.value, ndigits)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3.14159)\n&gt;&gt;&gt; result = round(s, 2)\n&gt;&gt;&gt; result.value\n3.14\n&gt;&gt;&gt; s.value = 2.71828\n&gt;&gt;&gt; result.value\n2.72\n</code></pre>"},{"location":"api/#signified.core.Computed.__ceil__","title":"__ceil__","text":"<pre><code>__ceil__()\n</code></pre> <p>Return a reactive value for the ceiling of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.ceil(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import ceil\n&gt;&gt;&gt; s = Signal(3.14)\n&gt;&gt;&gt; result = ceil(s)\n&gt;&gt;&gt; result.value\n4\n&gt;&gt;&gt; s.value = 2.01\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Computed.__floor__","title":"__floor__","text":"<pre><code>__floor__()\n</code></pre> <p>Return a reactive value for the floor of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A reactive value for <code>math.floor(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import floor\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = floor(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4.01\n&gt;&gt;&gt; result.value\n4\n</code></pre>"},{"location":"api/#signified.core.Computed.__invert__","title":"__invert__","text":"<pre><code>__invert__() -&gt; Computed[int]\n</code></pre><pre><code>__invert__() -&gt; Computed[T]\n</code></pre> <pre><code>__invert__()\n</code></pre> <p>Return a reactive value for the bitwise inversion of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>~self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = ~s\n&gt;&gt;&gt; result.value\n-6\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Computed.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; Computed[int]\n</code></pre><pre><code>__neg__() -&gt; Computed[T]\n</code></pre> <pre><code>__neg__()\n</code></pre> <p>Return a reactive value for the negation of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>-self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = -s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = -3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Computed.__pos__","title":"__pos__","text":"<pre><code>__pos__() -&gt; Computed[int]\n</code></pre><pre><code>__pos__() -&gt; Computed[T]\n</code></pre> <pre><code>__pos__()\n</code></pre> <p>Return a reactive value for the positive of self.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>+self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(-5)\n&gt;&gt;&gt; result = +s\n&gt;&gt;&gt; result.value\n-5\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Computed.__trunc__","title":"__trunc__","text":"<pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[int]\n</code></pre><pre><code>__trunc__() -&gt; Computed[T]\n</code></pre> <pre><code>__trunc__()\n</code></pre> <p>Return a reactive value for the truncated value of <code>self</code>.</p> <p>Returns:</p> Type Description <code>Computed[T] | Computed[int]</code> <p>A reactive value for <code>math.trunc(self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; from math import trunc\n&gt;&gt;&gt; s = Signal(3.99)\n&gt;&gt;&gt; result = trunc(s)\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = -4.01\n&gt;&gt;&gt; result.value\n-4\n</code></pre>"},{"location":"api/#signified.core.Computed.__add__","title":"__add__","text":"<pre><code>__add__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__add__(other: HasValue[Y]) -&gt; Computed[R]\n</code></pre><pre><code>__add__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__add__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s + 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.Computed.__and__","title":"__and__","text":"<pre><code>__and__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &amp; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s &amp; False\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.contains","title":"contains","text":"<pre><code>contains(other)\n</code></pre> <p>Return a reactive value for whether <code>other</code> is in <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to check for containment.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>other in self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4])\n&gt;&gt;&gt; result = s.contains(3)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = [5, 6, 7, 8]\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__divmod__","title":"__divmod__","text":"<pre><code>__divmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__divmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__divmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(self.value, other)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = divmod(s, 3)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 20\n&gt;&gt;&gt; result.value\n(6, 2)\n</code></pre>"},{"location":"api/#signified.core.Computed.is_not","title":"is_not","text":"<pre><code>is_not(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value is not other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; other = None\n&gt;&gt;&gt; result = s.is_not(other)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = None\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.eq","title":"eq","text":"<pre><code>eq(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> equals other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value == other.</p> Note <p>We can't overload <code>__eq__</code> because it interferes with basic Python operations.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s.eq(10)\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__floordiv__","title":"__floordiv__","text":"<pre><code>__floordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__floordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__floordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>self</code> by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for self.value // other.value.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s // 3\n&gt;&gt;&gt; result.value\n6\n&gt;&gt;&gt; s.value = 25\n&gt;&gt;&gt; result.value\n8\n</code></pre>"},{"location":"api/#signified.core.Computed.__ge__","title":"__ge__","text":"<pre><code>__ge__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt;= other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__gt__","title":"__gt__","text":"<pre><code>__gt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is greater than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for self.value &gt; other.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s &gt; 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__le__","title":"__le__","text":"<pre><code>__le__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than or equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt;= other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt;= 5\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__lt__","title":"__lt__","text":"<pre><code>__lt__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is less than <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value &lt; other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s &lt; 10\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__lshift__","title":"__lshift__","text":"<pre><code>__lshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> left-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &lt;&lt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(8)\n&gt;&gt;&gt; result = s &lt;&lt; 2\n&gt;&gt;&gt; result.value\n32\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.Computed.__matmul__","title":"__matmul__","text":"<pre><code>__matmul__(other)\n</code></pre> <p>Return a reactive value for the matrix multiplication of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value @ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = Signal(np.array([1, 2]))\n&gt;&gt;&gt; result = s @ np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; result.value\narray([ 7, 10])\n&gt;&gt;&gt; s.value = np.array([2, 3])\n&gt;&gt;&gt; result.value\narray([11, 16])\n</code></pre>"},{"location":"api/#signified.core.Computed.__mod__","title":"__mod__","text":"<pre><code>__mod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__mod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mod__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> modulo <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value % other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(17)\n&gt;&gt;&gt; result = s % 5\n&gt;&gt;&gt; result.value\n2\n&gt;&gt;&gt; s.value = 23\n&gt;&gt;&gt; result.value\n3\n</code></pre>"},{"location":"api/#signified.core.Computed.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__mul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__mul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__mul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = s * 3\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.Computed.__ne__","title":"__ne__","text":"<pre><code>__ne__(other)\n</code></pre> <p>Return a reactive value for whether <code>self</code> is not equal to <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A reactive value for <code>self.value != other</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = s != 5\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = 6\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Computed.__or__","title":"__or__","text":"<pre><code>__or__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = s | True\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Computed.__rshift__","title":"__rshift__","text":"<pre><code>__rshift__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> right-shifted by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value &gt;&gt; other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(32)\n&gt;&gt;&gt; result = s &gt;&gt; 2\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 24\n&gt;&gt;&gt; result.value\n6\n</code></pre>"},{"location":"api/#signified.core.Computed.__pow__","title":"__pow__","text":"<pre><code>__pow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__pow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__pow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = s ** 3\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.Computed.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value - other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = s - 3\n&gt;&gt;&gt; result.value\n7\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n12\n</code></pre>"},{"location":"api/#signified.core.Computed.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__truediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__truediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(20)\n&gt;&gt;&gt; result = s / 4\n&gt;&gt;&gt; result.value\n5.0\n&gt;&gt;&gt; s.value = 30\n&gt;&gt;&gt; result.value\n7.5\n</code></pre>"},{"location":"api/#signified.core.Computed.__xor__","title":"__xor__","text":"<pre><code>__xor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = s ^ False\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__radd__(other: HasValue[_SupportsAdd[T, R]]) -&gt; Computed[R]\n</code></pre><pre><code>__radd__(other: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__radd__(other)\n</code></pre> <p>Return a reactive value for the sum of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value + other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(5)\n&gt;&gt;&gt; result = 3 + s\n&gt;&gt;&gt; result.value\n8\n&gt;&gt;&gt; s.value = 10\n&gt;&gt;&gt; result.value\n13\n</code></pre>"},{"location":"api/#signified.core.Computed.__rand__","title":"__rand__","text":"<pre><code>__rand__(other)\n</code></pre> <p>Return a reactive value for the bitwise AND of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value and other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False &amp; s\n&gt;&gt;&gt; result.value\nFalse\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__rdivmod__","title":"__rdivmod__","text":"<pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[int]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: HasValue[bool]) -&gt; Computed[tuple[int, int]]\n</code></pre><pre><code>__rdivmod__(other: Any) -&gt; Computed[tuple[float, float]]\n</code></pre> <pre><code>__rdivmod__(other)\n</code></pre> <p>Return a reactive value for the divmod of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[int, int]] | Computed[tuple[float, float]]</code> <p>A reactive value for <code>divmod(other, self.value)</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = divmod(10, s)\n&gt;&gt;&gt; result.value\n(3, 1)\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n(2, 2)\n</code></pre>"},{"location":"api/#signified.core.Computed.__rfloordiv__","title":"__rfloordiv__","text":"<pre><code>__rfloordiv__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rfloordiv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rfloordiv__(other)\n</code></pre> <p>Return a reactive value for the floor division of <code>other</code> by <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the numerator.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value // self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 // s\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Computed.__rmod__","title":"__rmod__","text":"<pre><code>__rmod__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rmod__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmod__(other)\n</code></pre> <p>Return a reactive value for <code>other</code> modulo <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The dividend.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>other.value % self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(3)\n&gt;&gt;&gt; result = 10 % s\n&gt;&gt;&gt; result.value\n1\n&gt;&gt;&gt; s.value = 4\n&gt;&gt;&gt; result.value\n2\n</code></pre>"},{"location":"api/#signified.core.Computed.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__rmul__(other: HasValue[int]) -&gt; Computed[list[V]]\n</code></pre><pre><code>__rmul__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rmul__(other)\n</code></pre> <p>Return a reactive value for the product of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value * other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; result = 3 * s\n&gt;&gt;&gt; result.value\n12\n&gt;&gt;&gt; s.value = 5\n&gt;&gt;&gt; result.value\n15\n</code></pre>"},{"location":"api/#signified.core.Computed.__ror__","title":"__ror__","text":"<pre><code>__ror__(other)\n</code></pre> <p>Return a reactive value for the bitwise OR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value or other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(False)\n&gt;&gt;&gt; result = True | s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = True\n&gt;&gt;&gt; result.value\nTrue\n</code></pre>"},{"location":"api/#signified.core.Computed.__rpow__","title":"__rpow__","text":"<pre><code>__rpow__(other: HasValue[bool] | HasValue[int]) -&gt; Computed[int]\n</code></pre><pre><code>__rpow__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rpow__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> raised to the power of <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The base.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value ** other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 3 ** s\n&gt;&gt;&gt; result.value\n9\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n27\n</code></pre>"},{"location":"api/#signified.core.Computed.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> <p>Return a reactive value for the difference of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract from.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>other.value - self.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(10)\n&gt;&gt;&gt; result = 15 - s\n&gt;&gt;&gt; result.value\n5\n&gt;&gt;&gt; s.value = 15\n&gt;&gt;&gt; result.value\n0\n</code></pre>"},{"location":"api/#signified.core.Computed.__rtruediv__","title":"__rtruediv__","text":"<pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[int]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[bool] | HasValue[int] | HasValue[float]) -&gt; Computed[float]\n</code></pre><pre><code>__rtruediv__(other: HasValue[Y]) -&gt; Computed[T | Y]\n</code></pre> <pre><code>__rtruediv__(other)\n</code></pre> <p>Return a reactive value for <code>self</code> divided by <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value / other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(2)\n&gt;&gt;&gt; result = 30 / s\n&gt;&gt;&gt; result.value\n15.0\n&gt;&gt;&gt; s.value = 3\n&gt;&gt;&gt; result.value\n10.0\n</code></pre>"},{"location":"api/#signified.core.Computed.__rxor__","title":"__rxor__","text":"<pre><code>__rxor__(other)\n</code></pre> <p>Return a reactive value for the bitwise XOR of <code>self</code> and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A reactive value for <code>self.value ^ other.value</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal(True)\n&gt;&gt;&gt; result = False ^ s\n&gt;&gt;&gt; result.value\nTrue\n&gt;&gt;&gt; s.value = False\n&gt;&gt;&gt; result.value\nFalse\n</code></pre>"},{"location":"api/#signified.core.Computed.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: slice) -&gt; Computed[list[V]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[tuple[V, ...]]\n</code></pre><pre><code>__getitem__(key: slice) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[SupportsIndex] | HasValue[int]) -&gt; Computed[str]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: HasValue[K]) -&gt; Computed[V]\n</code></pre><pre><code>__getitem__(key: Any) -&gt; Computed[Any]\n</code></pre> <pre><code>__getitem__(key)\n</code></pre> <p>Return a reactive value for the item or slice of <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A reactive value for <code>self.value[key]</code>.</p> Example <pre><code>&gt;&gt;&gt; s = Signal([1, 2, 3, 4, 5])\n&gt;&gt;&gt; result = s[2]\n&gt;&gt;&gt; result.value\n3\n&gt;&gt;&gt; s.value = [10, 20, 30, 40, 50]\n&gt;&gt;&gt; result.value\n30\n</code></pre>"},{"location":"api/#signified.core.Computed.__setattr__","title":"__setattr__","text":"<pre><code>__setattr__(name, value)\n</code></pre> <p>Set an attribute on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the attribute via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even if one of its attributes changed.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <pre><code>    &gt;&gt;&gt; class Person:\n    ...    def __init__(self, name: str):\n    ...        self.name = name\n    ...    def greet(self) -&gt; str:\n    ...        return f\"Hi, I'm {self.name}!\"\n    &gt;&gt;&gt; s = Signal(Person(\"Alice\"))\n    &gt;&gt;&gt; result = s.greet()\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Alice!\"\n    &gt;&gt;&gt; s.name = \"Bob\"  # Modify attribute on Person instance through the reactive value s\n    &gt;&gt;&gt; result.value\n    \"Hi, I'm Bob!\"\n</code></pre>"},{"location":"api/#signified.core.Computed.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set an item on the underlying <code>self.value</code>.</p> Note <p>It is necessary to set the item via the Signal, rather than the underlying <code>signal.value</code>, to properly notify downstream observers of changes. Reason being, mutable objects that, for example, fallback to id comparison for equality checks will appear as if nothing changed even an element of the object is changed.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key to change.</p> required <code>value</code> <code>Any</code> <p>The value to set it to.</p> required Example <p>```py</p> <p>s = Signal([1, 2, 3]) result = computed(sum)(s) result.value 6 s[1] = 4 result.value 8</p>"},{"location":"api/#signified.core.Computed.where","title":"where","text":"<pre><code>where(a, b)\n</code></pre> <p>Return a reactive value for <code>a</code> if <code>self</code> is <code>True</code>, else <code>b</code>.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>HasValue[A]</code> <p>The value to return if <code>self</code> is <code>True</code>.</p> required <code>b</code> <code>HasValue[B]</code> <p>The value to return if <code>self</code> is <code>False</code>.</p> required <p>Returns:</p> Type Description <code>Computed[A | B]</code> <p>A reactive value for <code>a if self.value else b</code>.</p> Example <pre><code>&gt;&gt;&gt; condition = Signal(True)\n&gt;&gt;&gt; result = condition.where(\"Yes\", \"No\")\n&gt;&gt;&gt; result.value\n'Yes'\n&gt;&gt;&gt; condition.value = False\n&gt;&gt;&gt; result.value\n'No'\n</code></pre>"},{"location":"api/#signified.core.Computed.subscribe","title":"subscribe","text":"<pre><code>subscribe(observer)\n</code></pre> <p>Subscribe an observer to this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to subscribe.</p> required"},{"location":"api/#signified.core.Computed.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe(observer)\n</code></pre> <p>Unsubscribe an observer from this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to unsubscribe.</p> required"},{"location":"api/#signified.core.Computed.observe","title":"observe","text":"<pre><code>observe(items)\n</code></pre> <p>Subscribe the observer (<code>self</code>) to all items that are Observable.</p> <p>This method handles arbitrarily nested iterables.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item, an iterable, or a nested structure of items to potentially subscribe to.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p>"},{"location":"api/#signified.core.Computed.unobserve","title":"unobserve","text":"<pre><code>unobserve(items)\n</code></pre> <p>Unsubscribe the observer (<code>self</code>) from all items that are Observable.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Any</code> <p>A single item or an iterable of items to potentially unsubscribe from.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>self</p>"},{"location":"api/#signified.core.Computed.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Represent the object in a way that shows the inner value.</p>"},{"location":"api/#signified.core.Computed.add_name","title":"add_name","text":"<pre><code>add_name(name)\n</code></pre>"},{"location":"api/#signified.core.Computed.__format__","title":"__format__","text":"<pre><code>__format__(format_spec)\n</code></pre> <p>Format the variable with custom display options.</p> <p>Format options: :n  - just the name (or type+id if unnamed) :d  - full debug info empty - just the value in brackets (default)</p>"},{"location":"api/#signified.core.computed","title":"computed","text":"<pre><code>computed(func)\n</code></pre> <p>Wrap a function so calls produce a reactive <code>Computed</code> result.</p> <p>The returned wrapper accepts plain values, reactive values, or nested containers that include reactive values. On each recomputation, arguments are normalized with :func:<code>deep_unref</code>, so <code>func</code> receives plain Python values.</p> <p>The created :class:<code>Computed</code> subscribes to reactive dependencies found in <code>args</code> and <code>kwargs</code> at call time. When any dependency updates, the function is re-evaluated and subscribers are notified.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>Function that computes a derived value from its inputs.</p> required <p>Returns:</p> Type Description <code>Callable[..., Computed[R]]</code> <p>A wrapper that returns a :class:<code>Computed</code> when called.</p> Example <pre><code>&gt;&gt;&gt; @computed\n... def total(price, quantity):\n...     return price * quantity\n&gt;&gt;&gt; price = Signal(10)\n&gt;&gt;&gt; quantity = Signal(2)\n&gt;&gt;&gt; subtotal = total(price, quantity)\n&gt;&gt;&gt; subtotal.value\n20\n&gt;&gt;&gt; quantity.value = 3\n&gt;&gt;&gt; subtotal.value\n30\n</code></pre>"},{"location":"api/#signified.core.unref","title":"unref","text":"<pre><code>unref(value)\n</code></pre> <p>Resolve a value by unwrapping reactive containers until plain data remains.</p> <p>This utility repeatedly unwraps :class:<code>Variable</code> objects by following their internal <code>_value</code> references, allowing callers to operate on the underlying Python value regardless of nesting depth.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>HasValue[T]</code> <p>Plain value, reactive value, or nested reactive value.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The fully unwrapped value.</p> Example <pre><code>&gt;&gt;&gt; nested = Signal(Signal(5))\n&gt;&gt;&gt; unref(nested)\n5\n</code></pre>"},{"location":"api/#signified.core.has_value","title":"has_value","text":"<pre><code>has_value(obj, type_)\n</code></pre> <p>Check whether an object's resolved value is an instance of <code>type_</code>.</p> <p>This helper is a typed guard around :func:<code>unref</code>. It is useful when code accepts either plain values or reactive values and needs a narrowed type before continuing.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Value to inspect. May be plain or reactive.</p> required <code>type_</code> <code>type[T]</code> <p>Expected resolved value type.</p> required <p>Returns:</p> Type Description <code>TypeGuard[HasValue[T]]</code> <p><code>True</code> if <code>unref(obj)</code> is an instance of <code>type_</code>; otherwise</p> <code>TypeGuard[HasValue[T]]</code> <p><code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; candidate = Signal(42)\n&gt;&gt;&gt; has_value(candidate, int)\nTrue\n&gt;&gt;&gt; has_value(candidate, str)\nFalse\n</code></pre>"},{"location":"api/#signified.core.deep_unref","title":"deep_unref","text":"<pre><code>deep_unref(value)\n</code></pre> <p>Recursively resolve reactive values within nested containers.</p> <p><code>deep_unref</code> is the structural counterpart to :func:<code>unref</code>. It unwraps reactive values that appear inside supported containers while preserving the container type where practical.</p> <p>Supported behavior: - scalar primitives are returned unchanged - reactive values are unwrapped recursively - <code>dict</code>, <code>list</code>, and <code>tuple</code> contents are recursively unwrapped - generic iterables are reconstructed when possible; otherwise returned as-is - <code>numpy.ndarray</code> values with <code>dtype=object</code> are recursively unwrapped   element-wise</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Any value, possibly containing reactive values.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Value with reactive nodes recursively replaced by plain values.</p> Example <pre><code>&gt;&gt;&gt; payload = {\"a\": Signal(1), \"b\": [Signal(2), 3]}\n&gt;&gt;&gt; deep_unref(payload)\n{'a': 1, 'b': [2, 3]}\n</code></pre>"},{"location":"api/#signified.core.reactive_method","title":"reactive_method","text":"<pre><code>reactive_method(*dep_names)\n</code></pre> <p>Decorate an instance method so calls return a <code>Computed</code> value.</p> <p>The decorated method keeps its original call signature but now returns a reactive value. Dependencies include: - instance attributes named in <code>dep_names</code> (when present), and - call-time <code>args</code> and <code>kwargs</code>.</p> <p>This is useful for class APIs where a derived value depends on reactive fields owned by <code>self</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*dep_names</code> <code>str</code> <p>Attribute names on <code>self</code> to observe as dependencies.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[InstanceMethod[P, T]], ReactiveMethod[P, T]]</code> <p>A decorator that transforms an instance method into one that returns</p> <code>Callable[[InstanceMethod[P, T]], ReactiveMethod[P, T]]</code> <p>class:<code>Computed</code>.</p> Example <pre><code>&gt;&gt;&gt; from signified import Signal, reactive_method\n&gt;&gt;&gt; class Counter:\n...     def __init__(self):\n...         self.count = Signal(1)\n...     @reactive_method(\"count\")\n...     def doubled(self):\n...         return self.count.value * 2\n&gt;&gt;&gt; c = Counter()\n&gt;&gt;&gt; result = c.doubled()\n&gt;&gt;&gt; result.value\n2\n&gt;&gt;&gt; c.count.value = 4\n&gt;&gt;&gt; result.value\n8\n</code></pre>"},{"location":"api/#signified.core.as_signal","title":"as_signal","text":"<pre><code>as_signal(val)\n</code></pre> <p>Normalize a value to a signal-compatible reactive object.</p> <p>If <code>val</code> is already reactive, it is returned unchanged to avoid wrapping an existing reactive node. Otherwise a new :class:<code>Signal</code> is created.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>HasValue[T]</code> <p>Plain value or reactive value.</p> required <p>Returns:</p> Type Description <code>Signal[T]</code> <p>A reactive value suitable for APIs expecting <code>Signal</code>-like behavior.</p> Note <p>Existing reactive values are returned as-is at runtime, including <code>Computed</code> instances.</p> Example <pre><code>&gt;&gt;&gt; from signified import Signal, as_signal\n&gt;&gt;&gt; as_signal(3).value\n3\n&gt;&gt;&gt; s = Signal(4)\n&gt;&gt;&gt; as_signal(s) is s\nTrue\n</code></pre>"},{"location":"changes/","title":"Change Log","text":"<p>This page summarizes key changes by diffing adjacent tagged releases.</p>"},{"location":"changes/#027","title":"0.2.7","text":"<ul> <li>Significantly improve type inference for a variety of methods.</li> <li>Disable plugins by default (now enabled via environment variable, <code>SIGNIFIED_ENABLE_HOOKS=1</code>)</li> <li>Several performance improvements.</li> <li>Expand documentation.</li> <li>Migrate CI to <code>uv</code></li> </ul> <p>Breaking Changes: - Plugins now disabled by default. - Renamed <code>OrderedSet</code> and <code>OrderedWeakRefSet</code> to <code>_OrderedSet</code> and <code>_OrderedWeakRefSet</code>. (You shouldn't be using these anyways...)</p>"},{"location":"changes/#026","title":"0.2.6","text":"<ul> <li>Fixed packaging so NumPy is truly optional.</li> <li>Fixed Python 3.14 compatibility behavior.</li> <li>Expanded/updated CI test matrix for newer Python versions.</li> </ul>"},{"location":"changes/#025","title":"0.2.5","text":"<ul> <li>Improved weak-reference handling in the reactive observer internals.</li> <li>Updated core/type integration around weakref sets.</li> <li>Minor release metadata/version updates.</li> </ul>"},{"location":"changes/#024","title":"0.2.4","text":"<ul> <li>Made IPython an optional dependency.</li> <li>Removed hard NumPy dependency from base install requirements.</li> <li>Updated core/display logic to support optional imports.</li> </ul>"},{"location":"changes/#023","title":"0.2.3","text":"<ul> <li>Fixed runtime typing issue for generic forward references (<code>ReactiveValue</code>/<code>HasValue</code> usage).</li> <li>Added/expanded API documentation pages and MkDocs configuration.</li> <li>Updated docs deployment workflow.</li> </ul>"},{"location":"changes/#022","title":"0.2.2","text":"<ul> <li>Refactored the implementation into smaller modules (<code>core</code>, <code>ops</code>, <code>display</code>, <code>types</code>, <code>utils</code>).</li> <li>Removed old monolithic implementation layout.</li> <li>Updated docs/test scaffolding to match the split structure.</li> </ul>"},{"location":"changes/#021","title":"0.2.1","text":"<ul> <li>Fixed <code>deep_unref</code> behavior to avoid coercing unknown iterables into lists.</li> <li>Minor packaging/version metadata adjustments.</li> </ul>"},{"location":"changes/#020","title":"0.2.0","text":"<ul> <li>Added plugin system support (<code>signified.plugins</code>) and plugin examples.</li> <li>Added <code>deep_unref</code>, memory/performance cleanup (<code>__slots__</code>), and typing improvements.</li> <li>Substantially expanded docs (<code>usage</code>, <code>limitations</code>, <code>plugins</code>, changelog, theme updates).</li> </ul>"},{"location":"changes/#015","title":"0.1.5","text":"<ul> <li>Major expansion of core reactive implementation and type-inference coverage.</li> <li>Improved observe/unobserve and change-detection robustness.</li> <li>Added release/docs workflow improvements and changelog updates.</li> </ul>"},{"location":"changes/#014","title":"0.1.4","text":"<ul> <li>Repackaged project into <code>src/signified/</code> package layout.</li> <li>Ensured <code>py.typed</code> ships from package directory.</li> <li>Minor README/metadata cleanup.</li> </ul>"},{"location":"changes/#013","title":"0.1.3","text":"<ul> <li>Improved README and docs landing content.</li> <li>Fixed MkDocs configuration issues.</li> <li>Minor source and metadata tweaks.</li> </ul>"},{"location":"changes/#012","title":"0.1.2","text":"<ul> <li>Added support for Python versions <code>&gt;=3.9</code> (at that time).</li> <li>Added broad tests for signals/computed/reactive methods/type inference.</li> <li>Added/updated CI test workflow and moved to <code>src/</code> source layout.</li> </ul>"},{"location":"changes/#011","title":"0.1.1","text":"<ul> <li>Fixed package naming/docs after rename.</li> <li>Updated project URLs and version metadata.</li> <li>Updated changelog entries for the rename transition.</li> </ul>"},{"location":"changes/#010","title":"0.1.0","text":"<ul> <li>Initial tagged release as <code>signified</code>.</li> </ul>"},{"location":"limitations/","title":"Known Limitations","text":""},{"location":"limitations/#type-inference","title":"Type Inference","text":"<p>This library's type hints do not work with <code>mypy</code>, but they do work well with <code>pyright</code>.</p>"},{"location":"limitations/#in-place-mutation-of-mutable-collections","title":"In-Place Mutation of Mutable Collections","text":"<p>When working with values like <code>list</code> and <code>dict</code>, mutating via methods on the underlying object does not automatically notify observers.</p> <pre><code>from signified import Signal, computed\n\n# This won't work as expected\nnumbers = Signal([1, 2, 3])\nsum_numbers = computed(sum)(numbers)\nprint(sum_numbers.value)  # 6\n\nnumbers.value.append(4)   # Mutation doesn't trigger update\nprint(sum_numbers.value)  # Still 6, not 10 as expected\n\n# Instead, do one of these:\n# 1. Assign a new list\nnumbers.value = [1, 2, 3, 4]\nprint(sum_numbers.value)  # 10\n\n# 2. Create a new list with the existing values\nnumbers.value = numbers.value + [4]\nprint(sum_numbers.value) # 10\n\n# 3. For lists/dicts, use __setitem__ on the signal\nnumbers[0] = 99\nprint(sum_numbers.value)  # 108\n</code></pre>"},{"location":"limitations/#plugin-hooks-are-opt-in","title":"Plugin Hooks Are Opt-In","text":"<p>Plugin hooks are disabled by default. To enable hook execution, install the plugin extra and set:</p> <pre><code>SIGNIFIED_ENABLE_HOOKS=1\n</code></pre>"},{"location":"magic-methods/","title":"Magic Methods and Operators","text":"<p>Signified exposes reactive behavior primarily through magic methods on <code>Signal</code> and <code>Computed</code>.</p>"},{"location":"magic-methods/#unary-methods","title":"Unary Methods","text":"Method Usage example Notes <code>__abs__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(-5)</code><code>&gt;&gt;&gt; abs(x)</code><code>&lt;5&gt;</code> <code>__neg__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; -x</code><code>&lt;-10&gt;</code> <code>__pos__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; +x</code><code>&lt;10&gt;</code> <code>__invert__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; flags = Signal(0b0011)</code><code>&gt;&gt;&gt; ~flags</code><code>&lt;-4&gt;</code> Commonly used with bitmasks. <code>__round__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(3.14159)</code><code>&gt;&gt;&gt; round(x, 2)</code><code>&lt;3.14&gt;</code> <code>__trunc__</code> <code>&gt;&gt;&gt; import math</code><code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(3.9)</code><code>&gt;&gt;&gt; math.trunc(x)</code><code>&lt;3&gt;</code> <code>__floor__</code> <code>&gt;&gt;&gt; import math</code><code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(3.9)</code><code>&gt;&gt;&gt; math.floor(x)</code><code>&lt;3&gt;</code> <code>__ceil__</code> <code>&gt;&gt;&gt; import math</code><code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(3.1)</code><code>&gt;&gt;&gt; math.ceil(x)</code><code>&lt;4&gt;</code> <code>__str__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; str(x)</code><code>'10'</code> String conversion is not reactive."},{"location":"magic-methods/#arithmetic-and-bitwise-methods","title":"Arithmetic and Bitwise Methods","text":"Method Usage example Notes <code>__add__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a + b</code><code>&lt;13&gt;</code> <code>__sub__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a - b</code><code>&lt;7&gt;</code> <code>__mul__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a * b</code><code>&lt;30&gt;</code> <code>__truediv__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a / b</code><code>&lt;3.3333333333333335&gt;</code> <code>__floordiv__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a // b</code><code>&lt;3&gt;</code> <code>__mod__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a % b</code><code>&lt;1&gt;</code> <code>__pow__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a ** b</code><code>&lt;1000&gt;</code> <code>__divmod__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; divmod(a, b)</code><code>&lt;(3, 1)&gt;</code> <code>__matmul__</code> <code>&gt;&gt;&gt; import numpy as np</code><code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; left = Signal(np.array([1, 2]))</code><code>&gt;&gt;&gt; right = Signal(np.array([1, 1]))</code><code>&gt;&gt;&gt; left @ right</code><code>&lt;3&gt;</code> <code>__and__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(0b1100)</code><code>&gt;&gt;&gt; b = Signal(0b1010)</code><code>&gt;&gt;&gt; a &amp; b</code><code>&lt;8&gt;</code> <code>__or__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(0b1100)</code><code>&gt;&gt;&gt; b = Signal(0b1010)</code><code>&gt;&gt;&gt; a | b</code><code>&lt;14&gt;</code> <code>__xor__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(0b1100)</code><code>&gt;&gt;&gt; b = Signal(0b1010)</code><code>&gt;&gt;&gt; a ^ b</code><code>&lt;6&gt;</code> <code>__lshift__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; x &lt;&lt; 1</code><code>&lt;20&gt;</code> <code>__rshift__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; x &gt;&gt; 1</code><code>&lt;5&gt;</code>"},{"location":"magic-methods/#reverse-arithmetic-and-bitwise-methods","title":"Reverse Arithmetic and Bitwise Methods","text":"Method Usage example Notes <code>__radd__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 5 + x</code><code>&lt;15&gt;</code> <code>__rsub__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 50 - x</code><code>&lt;40&gt;</code> <code>__rmul__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 5 * x</code><code>&lt;50&gt;</code> <code>__rtruediv__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 50 / x</code><code>&lt;5.0&gt;</code> <code>__rfloordiv__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 50 // x</code><code>&lt;5&gt;</code> <code>__rmod__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 50 % x</code><code>&lt;0&gt;</code> <code>__rpow__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; 2 ** x</code><code>&lt;1024&gt;</code> <code>__rdivmod__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; divmod(50, x)</code><code>&lt;(5, 0)&gt;</code> <code>__rand__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(0b0101)</code><code>&gt;&gt;&gt; 0b1111 &amp; x</code><code>&lt;5&gt;</code> <code>__ror__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(0b0101)</code><code>&gt;&gt;&gt; 0b1111 | x</code><code>&lt;15&gt;</code> <code>__rxor__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(0b0101)</code><code>&gt;&gt;&gt; 0b1111 ^ x</code><code>&lt;10&gt;</code>"},{"location":"magic-methods/#comparisons-predicates-and-truthiness","title":"Comparisons, Predicates, and Truthiness","text":"Method Usage example Notes <code>__lt__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a &lt; b</code><code>&lt;False&gt;</code> <code>__le__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a &lt;= b</code><code>&lt;False&gt;</code> <code>__gt__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a &gt; b</code><code>&lt;True&gt;</code> <code>__ge__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a &gt;= b</code><code>&lt;True&gt;</code> <code>__ne__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a != b</code><code>&lt;True&gt;</code> <code>eq</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; a = Signal(10)</code><code>&gt;&gt;&gt; b = Signal(3)</code><code>&gt;&gt;&gt; a.eq(b)</code><code>&lt;False&gt;</code> Overloading <code>__eq__</code> would break the object, so we use an explicit method, <code>a.eq(b)</code> as an analog to <code>a == b</code>. <code>is_not</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; maybe_user = Signal(None)</code><code>&gt;&gt;&gt; maybe_user.is_not(None)</code><code>&lt;False&gt;</code> <code>is</code> / <code>is not</code> are not overloadable. Use this for reactive identity-style checks. <code>contains</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; nums = Signal([1, 2, 3])</code><code>&gt;&gt;&gt; nums.contains(2)</code><code>&lt;True&gt;</code> <code>where</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; flag = Signal(True)</code><code>&gt;&gt;&gt; flag.where(\"yes\", \"no\")</code><code>&lt;yes&gt;</code> <code>as_bool</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; x = Signal(10)</code><code>&gt;&gt;&gt; x.as_bool()</code><code>&lt;True&gt;</code> <code>__bool__</code> cannot safely be reactive because Python expects an immediate bool in control flow."},{"location":"magic-methods/#object-and-container-access","title":"Object and Container Access","text":"Method Usage example Notes <code>__getattr__</code> <code>&gt;&gt;&gt; from types import SimpleNamespace</code><code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; person = Signal(SimpleNamespace(name=\"Alice\"))</code><code>&gt;&gt;&gt; person.name</code><code>&lt;Alice&gt;</code> <code>__call__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; fn = Signal(lambda x: x + 1)</code><code>&gt;&gt;&gt; fn(10)</code><code>&lt;11&gt;</code> <code>__getitem__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; Signal([1, 2, 3])[1]</code><code>&lt;2&gt;</code><code>&gt;&gt;&gt; Signal({\"x\": 1})[\"x\"]</code><code>&lt;1&gt;</code> <code>__setattr__</code> <code>&gt;&gt;&gt; from types import SimpleNamespace</code><code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; person = Signal(SimpleNamespace(name=\"Alice\"))</code><code>&gt;&gt;&gt; name = person.name</code><code>&gt;&gt;&gt; person.name = \"Bob\"</code><code>&gt;&gt;&gt; name</code><code>&lt;Bob&gt;</code> Updates wrapped object attributes and notifies dependents. <code>__setitem__</code> <code>&gt;&gt;&gt; from signified import Signal</code><code>&gt;&gt;&gt; nums = Signal([1, 2, 3])</code><code>&gt;&gt;&gt; first = nums[0]</code><code>&gt;&gt;&gt; nums[0] = 10</code><code>&gt;&gt;&gt; first</code><code>&lt;10&gt;</code> Works for wrapped <code>list</code>/<code>dict</code> item updates."},{"location":"magic-methods/#complete-api-reference","title":"Complete API Reference","text":"<p>See Core API for full signatures, overloads, and docstring examples.</p>"},{"location":"plugins/","title":"Writing Plugins","text":"<p>Signified provides a plugin system built on top of pluggy.</p>"},{"location":"plugins/#important-hooks-are-disabled-by-default","title":"Important: Hooks Are Disabled by Default","text":"<p>By default, <code>signified.plugins.pm</code> is a no-op manager. To activate real hooks:</p> <ol> <li> <p>Install plugin support:</p> <pre><code>pip install \"signified[plugins]\"\n</code></pre> </li> <li> <p>Run with:</p> <pre><code>SIGNIFIED_ENABLE_HOOKS=1\n</code></pre> </li> </ol> <p>Without this environment variable set, plugin hooks will not execute.</p>"},{"location":"plugins/#plugin-hooks","title":"Plugin Hooks","text":"<p>The plugin system provides hooks for key events in a reactive value's lifecycle:</p> <ul> <li><code>read</code>: Called whenever a reactive value's current value is accessed</li> <li><code>created</code>: Called when a new reactive value is instantiated</li> <li><code>updated</code>: Called when a reactive value's content changes</li> <li><code>named</code>: Called when a reactive value is given a name</li> </ul> <p>These hooks allow plugins to observe and respond to the complete lifecycle of reactive values.</p>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":"<p>Implement hooks with <code>@hookimpl</code>, then register with <code>pm</code>:</p> <pre><code>from typing import Any\n\nfrom signified import Signal, Variable\nfrom signified.plugins import hookimpl, pm\n\nclass MyPlugin:\n    def __init__(self) -&gt; None:\n        self.created_count = 0\n\n    @hookimpl\n    def created(self, value: Variable[Any]) -&gt; None:\n        self.created_count += 1\n        print(f\"created: {value:d}\")\n\nplugin = MyPlugin()\npm.register(plugin)\n\nx = Signal(1)\ny = x + 1\nprint(plugin.created_count)  # 2 when hooks are enabled\n\npm.unregister(plugin)\n</code></pre>"},{"location":"plugins/#plugin-management","title":"Plugin Management","text":"<p>The global manager lives at <code>signified.plugins.pm</code>:</p> <pre><code>from signified.plugins import pm\n\npm.register(my_plugin)\npm.unregister(my_plugin)\n</code></pre>"},{"location":"plugins/#logging-example","title":"Logging Example","text":"<pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any\n\nfrom signified import Signal, Variable\nfrom signified.plugins import hookimpl, pm\n\n\nclass ReactiveLogger:\n    def __init__(self, logger: Any | None = None):\n        if logger is None:\n            _logger = logging.getLogger(__name__)\n            handler = logging.StreamHandler()\n            formatter = logging.Formatter(\"%(message)s\")\n            handler.setFormatter(formatter)\n            _logger.addHandler(handler)\n            _logger.setLevel(logging.INFO)\n        else:\n            _logger = logger\n        self.logger = _logger\n\n    @hookimpl\n    def created(self, value: Variable[Any]) -&gt; None:\n        self.logger.info(f\"Created {value:d}\")\n\n    @hookimpl\n    def updated(self, value: Variable[Any]) -&gt; None:\n        self.logger.info(f\"Updated {value:n} to {value.value}\")\n\n    @hookimpl\n    def named(self, value: Variable[Any]) -&gt; None:\n        self.logger.info(f\"Named {type(value).__name__}(id={id(value)}) as {value:n}\")\n\nlogger_plugin = ReactiveLogger()\npm.register(logger_plugin)\n\nx = Signal(1).add_name(\"x\")\ny = (x + 1).add_name(\"y\")\nx.value = 5\nprint(y.value)  # 6\n\npm.unregister(logger_plugin)\n</code></pre>"},{"location":"usage/","title":"Usage Guide","text":"<p>Because this package relies so heavily on overriding \"magic methods\", the API documentation for this package makes it hard to get an idea of how <code>signified</code> works. This page gives a crash course through several usage examples.</p>"},{"location":"usage/#signals-and-computed-values","title":"Signals and Computed Values","text":"<p><code>Signal</code> holds mutable state.</p> <p><code>Computed</code> represents derived state. It subscribes to dependencies and updates when they change.</p>"},{"location":"usage/#reading-the-underlying-value-value","title":"Reading the underlying value (<code>.value</code>)","text":"<p><code>Signal</code> and <code>Computed</code> display as <code>&lt;...&gt;</code> to indicate they are reactive objects. Use <code>.value</code> when you need the plain Python value.</p> <pre><code>from signified import Signal\n\nprice = Signal(19.99)\nquantity = Signal(2)\nsubtotal = price * quantity\n\nprint(subtotal)        # &lt;39.98&gt; (reactive)\nprint(subtotal.value)  # 39.98   (plain float)\n\nquantity.value = 3\nprint(subtotal.value)  # 59.97\n</code></pre> <p><code>Signal.value</code> is read/write. <code>Computed.value</code> is read-only and updates from dependencies.</p>"},{"location":"usage/#computed-from-operators","title":"Computed from operators","text":"<pre><code>from signified import Signal\n\nprice = Signal(19.99)\nquantity = Signal(2)\nsubtotal = price * quantity\n\nprint(subtotal)  # &lt;39.98&gt;\nquantity.value = 3\nprint(subtotal)  # &lt;59.97&gt;\n</code></pre>"},{"location":"usage/#computed-from-functions-computed","title":"Computed from functions (<code>@computed</code>)","text":"<pre><code>from signified import Signal, computed\n\nnumbers = Signal([1, 2, 3, 4, 5])\n\n@computed\ndef stats(nums):\n    return {\n        \"sum\": sum(nums),\n        \"mean\": sum(nums) / len(nums),\n        \"min\": min(nums),\n        \"max\": max(nums),\n    }\n\nresult = stats(numbers)\nprint(result)  # &lt;{'sum': 15, 'mean': 3.0, 'min': 1, 'max': 5}&gt;\n\nnumbers.value = [2, 4, 6, 8, 10]\nprint(result)  # &lt;{'sum': 30, 'mean': 6.0, 'min': 2, 'max': 10}&gt;\n</code></pre>"},{"location":"usage/#composing-computed-values","title":"Composing Computed values","text":"<p><code>Computed</code> values can be used as dependencies for other computed values.</p> <pre><code>from signified import Signal, computed\n\nx = Signal(3)\nx_squared = x**2\n\n@computed\ndef plus_one(v):\n    return v + 1\n\ny = plus_one(x_squared)\nprint(y)  # &lt;10&gt;\n\nx.value = 5\nprint(y)  # &lt;26&gt;\n</code></pre> <p>This composition is the core pattern: define state once, derive the rest.</p>"},{"location":"usage/#attribute-access-method-calls-and-assignment","title":"Attribute Access, Method Calls, and Assignment","text":"<p>You can reactively read attributes and call methods from objects inside signals.</p> <pre><code>from dataclasses import dataclass\nfrom signified import Signal\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n    def greet(self):\n        return f\"Hello, I'm {self.name} and I'm {self.age} years old!\"\n\nperson = Signal(Person(\"Alice\", 30))\n\nname_display = person.name\ngreeting = person.greet()\n\nprint(name_display)  # &lt;\"Alice\"&gt;\nprint(greeting)      # &lt;\"Hello, I'm Alice and I'm 30 years old!\"&gt;\n\n# __setattr__ support updates the wrapped object and notifies dependents\nperson.name = \"Bob\"\nprint(name_display)  # &lt;\"Bob\"&gt;\nprint(greeting)      # &lt;\"Hello, I'm Bob and I'm 30 years old!\"&gt;\n</code></pre> <p>Method chaining works too:</p> <pre><code>from signified import Signal\n\ntext = Signal(\"  Hello, World!  \")\nprocessed = text.strip().lower().replace(\",\", \"\")\n\nprint(processed)  # &lt;\"hello world!\"&gt;\ntext.value = \"  Goodbye, World!  \"\nprint(processed)  # &lt;\"goodbye world!\"&gt;\n</code></pre>"},{"location":"usage/#collections-and-item-assignment","title":"Collections and Item Assignment","text":"<p>Indexing is reactive, and <code>__setitem__</code> can notify dependents for <code>list</code> and <code>dict</code>.</p> <pre><code>from signified import Signal, computed\n\nnumbers = Signal([1, 2, 3])\ntotal = computed(sum)(numbers)\n\nprint(numbers[0])  # &lt;1&gt;\nprint(total)       # &lt;6&gt;\n\nprint(total)       # &lt;14&gt;\n</code></pre> <pre><code>from signified import Signal\n\nconfig = Signal({\"theme\": \"dark\", \"font_size\": 14})\ntheme = config[\"theme\"]\n\nprint(theme)  # &lt;\"dark\"&gt;\nconfig[\"theme\"] = \"light\"\nprint(theme)  # &lt;\"light\"&gt;\n</code></pre>"},{"location":"usage/#conditional-logic-with-where","title":"Conditional Logic with <code>where</code>","text":"<p><code>where(a, b)</code> picks <code>a</code> when the condition is truthy, otherwise <code>b</code>.</p> <pre><code>from signified import Signal, computed\n\nusername = Signal(None)\nis_logged_in = username.is_not(None)\n\n@computed\ndef welcome(name):\n    return f\"Welcome back, {name}!\"\n\nmessage = is_logged_in.where(welcome(username), \"Please log in\")\n\nprint(message)  # &lt;\"Please log in\"&gt;\nusername.value = \"admin\"\nprint(message)  # &lt;\"Welcome back, admin!\"&gt;\n</code></pre>"},{"location":"usage/#reactive_method","title":"<code>reactive_method</code>","text":"<p>Use <code>@reactive_method(...)</code> for instance methods that depend on reactive attributes.</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\n\nfrom signified import Signal, reactive_method\n\n@dataclass\nclass Item:\n    name: str\n    price: float\n\nclass Cart:\n    def __init__(self, items: List[Item]):\n        self.items = Signal(items)\n        self.tax_rate = Signal(0.125)\n\n    @reactive_method(\"items\", \"tax_rate\")\n    def total(self):\n        subtotal = sum(item.price for item in self.items.value)\n        return subtotal * (1 + self.tax_rate.value)\n\ncart = Cart([Item(\"Book\", 20), Item(\"Pen\", 4)])\ntotal_price = cart.total()\n\nprint(total_price)  # &lt;27.0&gt;\ncart.tax_rate.value = 0.25\nprint(total_price)  # &lt;30.0&gt;\ncart.items[0] = Item(\"Rare book?\", 400)\nprint(total_price)  # &lt;505.0&gt;\n</code></pre>"},{"location":"usage/#utility-helpers","title":"Utility Helpers","text":"<p><code>unref</code> makes functions work with either plain values or reactive values.</p> <pre><code>from signified import HasValue, Signal, unref\n\ndef process_data(value: HasValue[float]) -&gt; float:\n    return unref(value) * 2\n\nprint(process_data(4))          # 8\nprint(process_data(Signal(5)))  # 10\n</code></pre> <p>Related helpers:</p> <ul> <li><code>deep_unref</code>: recursively unwraps nested containers of reactive values</li> <li><code>as_signal</code>: wraps plain values into <code>Signal</code> (or returns the input signal)</li> <li><code>has_value</code>: type guard for checking <code>HasValue[T]</code></li> <li><code>Signal.at(...)</code>: temporary scoped value override via context manager</li> </ul>"}]}