{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Signified","text":"<p>Documentation: https://dougmercer.github.io/signified</p> <p>Source Code: https://github.com/dougmercer/signified</p> <p>A Python library for reactive programming (with kind-of working type narrowing).</p>"},{"location":"#getting-started","title":"Getting started","text":"<pre><code>pip install signified\n</code></pre>"},{"location":"#why-care","title":"Why care?","text":"<p><code>signified</code> is a reactive programming library that implements two primary data structures: <code>Signal</code> and <code>Computed</code>.</p> <p>Both of these objects implement the Observer and Observable design patterns. This means that they can notify other Observers if they change, and they can subscribe to be notified if another Observable changes.</p> <p>This allows us to create a network of computation, where one value being modified can trigger other objects to update.</p> <p>This allows us to write more declarative code, like,</p> <pre><code>x = Signal(3)\nx_squared = x ** 2  # currently equal to 9\nx.value = 10  # Will immediately notify x_squared, whose value will become 100.\n</code></pre> <p>Here, <code>x_squared</code> became a reactive expression (more specifically, a <code>Computed</code> object) whose value is always equal to <code>x ** 2</code>. Neat!</p> <p><code>signified</code>'s <code>Signal</code> object effectively gives us a container which stores a value, and <code>Computed</code> gives us a container to store the current value of a function. In the above example, we generated the Computed object on-the-fly using overloaded Python operators like <code>**</code>, but we could have just as easily done,</p> <pre><code>from signified import computed\n\n@computed\ndef power(x, n):\n    return x**n\n\nx_squared = power(x, 2)  # equivalent to the above\n</code></pre> <p>Together, these data structures allow us to implement a wide variety of capabilities. In particular, I wrote this library to make my to-be-released animation library easier to maintain and more fun to work with.</p>"},{"location":"#what-do-you-mean-by-kind-of-working-type-narrowing","title":"... what do you mean by \"kind of working type narrowing\"?","text":"<p>Other reactive Python libraries don't really attempt to implement type hints (e.g., param).</p> <p><code>signified</code> is type hinted and supports type narrowing even for nested reactive values.</p> <pre><code>from signified import Signal\n\na = Signal(1.0)\nb = Signal(Signal(Signal(2)))\nreveal_type(a + b)  # Computed[float | int]\n</code></pre> <p>Unfortunately, for the time being, our type hints only work with <code>pyright</code>.</p>"},{"location":"#ready-to-learn-more","title":"Ready to learn more?","text":"<p>Checkout the docs at https://dougmercer.github.io/signified or watch my YouTube video about the library.</p>"},{"location":"changes/","title":"Change Log","text":""},{"location":"changes/#020","title":"0.2.0","text":"<p>New Features</p> <ul> <li>Add a plugin system</li> </ul> <p>Performance</p> <ul> <li>Use slots to save memory</li> </ul> <p>Bugfixes</p> <ul> <li>Fix bug in unobserve method, replacing subscribe with unsubscribe</li> <li>Add a deep_unref function to handle some nested signal edge cases</li> </ul> <p>Type Inference</p> <ul> <li>Improve reactive_method's ability to properly infer types</li> </ul> <p>CI/CD</p> <ul> <li>Make ruff actually enforce isort-like imports</li> </ul> <p>Docs</p> <ul> <li>Improve Usage section of the docs</li> <li>Add a Limitations page to the docs</li> <li>Add a plugins page to the docs</li> </ul>"},{"location":"changes/#015","title":"0.1.5","text":"<p>Features</p> <ul> <li>Added <code>__setitem__</code> and <code>__setattr</code> methods for generating reactive values.</li> </ul> <p>Docs</p> <ul> <li>Added examples to docstrings (in doctest format).</li> </ul> <p>Bug Fixes</p> <ul> <li>Under several conditions, Reactive values generated from <code>__call__</code> and <code>__getitem__</code> weren't updating when an upstream observable was updated.</li> </ul> <p>Typing</p> <ul> <li>Improve type inference for <code>__call__</code> generated reactive values.</li> </ul>"},{"location":"changes/#014","title":"0.1.4","text":"<p>Minor changes to packaging and documentation</p>"},{"location":"changes/#011","title":"0.1.1","text":"<p>Initial release.</p>"},{"location":"limitations/","title":"Known Limitations","text":""},{"location":"limitations/#type-inference","title":"Type Inference","text":"<p>This library's type hints do not work with <code>mypy</code>, but they do work relatively well with <code>pyright</code>.</p>"},{"location":"limitations/#methods-on-mutable-collection","title":"Methods on Mutable Collection","text":"<p>When working with collections like <code>list</code>s, methods that mutate the underlying object don't trigger <code>signified</code> to notify observers:</p> <pre><code>from signified import Signal\n\n# This won't work as expected\nnumbers = Signal([1, 2, 3])\nsum_numbers = computed(sum)(numbers)\nprint(sum_numbers.value)  # 6\n\nnumbers.value.append(4)   # Mutation doesn't trigger update\nprint(sum_numbers.value)  # Still 6, not 10 as expected\n\n# Instead, do one of these:\n# 1. Assign a new list\nnumbers.value = [1, 2, 3, 4]\nprint(sum_numbers.value)  # 10\n\n# 2. Create a new list with the existing values\nnumbers.value = numbers.value + [4]\nprint(sum_numbers.value) # 10\n</code></pre>"},{"location":"plugins/","title":"Writing Plugins","text":"<p>Signified provides a plugin system built on top of pluggy that allows you to extend and customize its behavior. This guide explains the basics of creating plugins for signified.</p>"},{"location":"plugins/#plugin-hooks","title":"Plugin Hooks","text":"<p>The plugin system provides hooks for key events in a reactive value's lifecycle:</p> <ul> <li><code>read</code>: Called whenever a reactive value's current value is accessed</li> <li><code>created</code>: Called when a new reactive value is instantiated</li> <li><code>updated</code>: Called when a reactive value's content changes</li> <li><code>named</code>: Called when a reactive value is given a name</li> </ul> <p>These hooks allow plugins to observe and respond to the complete lifecycle of reactive values.</p> <p>Additional hooks may be added in the future. If you have a good idea for a plugin that would benefit from additional hooks, please let me know!</p>"},{"location":"plugins/#creating-a-plugin","title":"Creating a Plugin","text":"<p>To create a plugin:</p> <ol> <li>Create a class that will contain your hook implementations</li> <li>Implement any desired hooks using the <code>@hookimpl</code> decorator (available from <code>signified.plugin</code>)</li> <li>Register your plugin with the global plugin manager <code>pm</code> (also available in <code>signified.plugin</code>)</li> </ol> <p>Here's a minimal example:</p> <pre><code>from signified.plugin import hookimpl, pm\nfrom signified import ReactiveValue\nfrom typing import Any\n\nclass MyPlugin:\n    @hookimpl\n    def created(self, value: ReactiveValue[Any]) -&gt; None:\n        # Do something when a reactive value is created\n        pass\n\n# Register the plugin\nplugin = MyPlugin()\npm.register(plugin)\n</code></pre>"},{"location":"plugins/#plugin-management","title":"Plugin Management","text":"<p>The library maintains a global plugin manager instance in <code>signified.plugin.pm</code>. Plugins can be registered and unregistered at runtime:</p> <pre><code>from signified.plugin import pm\n\n# Register a plugin\npm.register(my_plugin)\n\n# Remove a plugin\npm.unregister(my_plugin)\n</code></pre>"},{"location":"plugins/#more-complex-example","title":"More complex example","text":"<p>I created a simple logging plugin.</p> <pre><code>from __future__ import annotations\n\nimport logging\nfrom typing import Any\n\nfrom signified import Variable\nfrom signified.plugin import hookimpl, pm\n\n\nclass ReactiveLogger:\n    \"\"\"A logger plugin for tracking reactive value lifecycle.\"\"\"\n\n    def __init__(self, logger: Any | None = None):\n        \"\"\"Initialize with optional logger, defaulting to standard logging.\"\"\"\n        if logger is None:\n            _logger = logging.getLogger(__name__)\n            handler = logging.StreamHandler()\n            formatter = logging.Formatter(\"%(message)s\")\n            handler.setFormatter(formatter)\n            _logger.addHandler(handler)\n            _logger.setLevel(logging.INFO)\n        else:\n            _logger = logger\n        self.logger = _logger\n\n    @hookimpl\n    def created(self, value: Variable[Any, Any]) -&gt; None:\n        \"\"\"Log when a reactive value is created.\n\n        Args:\n            value: The created reactive value\n        \"\"\"\n        self.logger.info(f\"Created {value:d}\")\n\n    @hookimpl\n    def updated(self, value: Variable[Any, Any]) -&gt; None:\n        \"\"\"Log when a reactive value is updated.\n\n        Args:\n            value: The updated reactive value\n        \"\"\"\n        self.logger.info(f\"Updated {value:n} to {value.value}\")\n\n    @hookimpl\n    def named(self, value: Variable[Any, Any]) -&gt; None:\n        \"\"\"Log when a reactive value is named.\n\n        Args:\n            value: The reactive value that was assigned a name.\n        \"\"\"\n        self.logger.info(f\"Named {type(value).__name__}(id={id(value)}) as {value:n}\")\n\nDEFAULT_LOGGING_PLUGIN = ReactiveLogger()\npm.register(DEFAULT_LOGGING_PLUGIN)\n</code></pre> <p>Here, we implement logging behavior for the <code>created</code>, <code>updated</code>, and <code>named</code> hooks.</p> <p>Finally, at the end, we create the plugin and register it to the plugin manager.</p>"},{"location":"usage/","title":"Usage Guide","text":"<p>Signified is a reactive programming library that helps you create and manage values that automatically update when their dependencies change. This guide will walk you through common usage patterns and features.</p>"},{"location":"usage/#basic-concepts","title":"Basic Concepts","text":""},{"location":"usage/#signals","title":"Signals","text":"<p>A <code>Signal</code> is a container for a mutable reactive value. When you change a signal's value, any computations that depend on it will automatically update.</p> <pre><code>from signified import Signal\n\nname = Signal(\"Alice\")\ngreeting = \"Hello, \" + name\n\nprint(greeting)  # \"Hello, Alice\"\nname.value = \"Bob\"\nprint(greeting)  # \"Hello, Bob\"\n</code></pre>"},{"location":"usage/#computed-values","title":"Computed Values","text":"<p>Computed values are derived from other reactive values. They can be constructed implicitly using overloaded Python operators or explicitly using the <code>computed</code> decorator.</p> <pre><code>from signified import Signal\n\na = Signal(3)\nb = Signal(4)\n\n# c is a Computed object that will automatically update when a or b are updated\nc = (a ** 2 + b ** 2) ** 0.5\n\nprint(c)  # 5\n\na.value = 5\nb.value = 12\n\nprint(c)  # 13\n</code></pre> <pre><code>from signified import Signal, computed\n\nnumbers = Signal([1, 2, 3, 4, 5])\n\n@computed\ndef stats(nums):\n    return {\n        'sum': sum(nums),\n        'mean': sum(nums) / len(nums),\n        'min': min(nums),\n        'max': max(nums)\n    }\n\nresult = stats(numbers)\nprint(result)  # {'sum': 15, 'mean': 3.0, 'min': 1, 'max': 5}\n\nnumbers.value = [2, 4, 6, 8, 10]\nprint(result)  # {'sum': 30, 'mean': 6.0, 'min': 2, 'max': 10}\n</code></pre>"},{"location":"usage/#working-with-data","title":"Working with Data","text":""},{"location":"usage/#collections-lists-dicts-etc","title":"Collections (Lists, Dicts, etc.)","text":"<p>Signified handles collections like lists and dictionaries somewhat well, but there are currently some rough edges.</p> <pre><code>from signified import Signal, computed\n\n# Working with lists\nnumbers = Signal([1, 2, 3, 4, 5])\ndoubled = computed(lambda x: [n * 2 for n in x])(numbers)\n\nprint(doubled)  # [2, 4, 6, 8, 10]\nnumbers.value = [5, 6, 7]\nprint(doubled)  # [10, 12, 14]\n\n# Modifying lists\nnumbers[0] = 10  # Notifies observers\nprint(numbers)  # [10, 6, 7]\n</code></pre> <pre><code>from signified import Signal, computed\n\n# Working with dictionaries\nconfig = Signal({\"theme\": \"dark\", \"fontSize\": 14})\ntheme = config[\"theme\"]\nfont_size = config[\"fontSize\"]\n\nprint(theme)      # \"dark\"\nprint(font_size)  # 14\n\nconfig.value = {\"theme\": \"light\", \"fontSize\": 16}\nprint(theme)      # \"light\"\nprint(font_size)  # 16\n</code></pre>"},{"location":"usage/#numpy","title":"NumPy","text":"<p>Signified integrates well with NumPy arrays:</p> <pre><code>from signified import Signal\nimport numpy as np\n\nmatrix = Signal(np.array([[1, 2], [3, 4]]))\nvector = Signal(np.array([1, 1]))\n\nresult = matrix @ vector  # Matrix multiplication\n\nprint(result)  # array([3, 7])\n\nmatrix.value = np.array([[2, 2], [4, 4]])\nprint(result)  # array([4, 8])\n</code></pre>"},{"location":"usage/#other-topics","title":"Other Topics","text":""},{"location":"usage/#conditional-logic","title":"Conditional Logic","text":"<p>Use the <code>where()</code> method for conditional computations:</p> <pre><code>from signified import Signal\n\nusername = Signal(None)\nis_logged_in = username.is_not(None)\n\nmessage = is_logged_in.where(f\"Welcome back, {username}!\", \"Please log in\")\n\nprint(message)  # \"Please log in\"\nusername.value = \"admin\"\nprint(message)  # \"Welcome back, admin!\"\n</code></pre>"},{"location":"usage/#reactive-attribute-access-and-method-calls","title":"Reactive Attribute Access and Method Calls","text":"<p>Signified supports reactively accessing attributes, properties, or methods on the underlying value.</p> <p>Here, we construct a simple class and show that we can create <code>Computed</code> objects that reactively track the value of attributes stored within he underlying object.</p> <pre><code>from dataclasses import dataclass\nfrom signified import Signal\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n    def greet(self):\n        return f\"Hello, I'm {self.name} and I'm {self.age} years old!\"\n\nperson = Signal(Person(\"Alice\", 30))\n\n# Access attributes reactively\nname_display = person.name\nage_display = person.age\ngreeting = person.greet()\n\nprint(name_display)  # \"Alice\"\nprint(age_display)  # 30\nprint(greeting)     # \"Hello, I'm Alice and I'm 30 years old!\"\n\n# Update through the signal\nperson.name = \"Bob\"\nperson.age = 35\n\nprint(name_display)  # \"Bob\"\nprint(age_display)  # 35\nprint(greeting)     # \"Hello, I'm Bob and I'm 35 years old!\"\n</code></pre> <p>Therefore, if the underlying object supports method chaining, we can easily create reactive values that apply several methods in sequence.</p> <pre><code>from signified import Signal\n\ntext = Signal(\"  Hello, World!  \")\nprocessed = text.strip().lower().replace(\",\", \"\")\n\nprint(processed.value)  # \"hello world!\"\ntext.value = \"  Goodbye, World!  \"\nprint(processed.value)  # \"goodbye world!\"\n</code></pre>"},{"location":"usage/#the-reactive_method-decorator","title":"The reactive_method decorator","text":"<p>Use the <code>@reactive_method</code> decorator to turn a non-reactive method into a reactive one.</p> <pre><code>from dataclasses import dataclass\nfrom typing import List\n\nfrom signified import Signal, reactive_method\n\n@dataclass\nclass Item:\n    name: str\n    price: float\n\nclass Cart:\n    def __init__(self, items: List[Item]):\n        self.items = Signal(items)\n        self.tax_rate = Signal(0.125)\n\n    # Providing the names of the reactive values this method depends on tells\n    # signified to monitor them for updates\n    @reactive_method('items', 'tax_rate')\n    def total(self):\n        subtotal = sum(item.price for item in self.items.value)\n        return subtotal * (1 + self.tax_rate)\n\nitems = [Item(name=\"Book\", price=20), Item(name=\"Pen\", price=4)]\ncart = Cart(items)\n\ntotal_price = cart.total()\nprint(total_price)  # 27 (24 * 1.125)\ncart.tax_rate.value = 0.25\nprint(total_price)  # 30 (24 * 1.25)\ncart.items[0] = Item(name=\"Rare book?\", price=400)\nprint(total_price)  # 505 (404 * 1.25)\n</code></pre>"},{"location":"usage/#understanding-unref","title":"Understanding <code>unref</code>","text":"<p>The <code>unref</code> function is particularly useful when working with values that might be either reactive or non-reactive. This is common when writing functions that should handle both types transparently.</p> <pre><code>from signified import HasValue, Signal, unref\n\ndef process_data(value: HasValue[float]):\n    # unref handles both reactive and non-reactive values\n    actual_value = unref(value)\n    return actual_value * 2\n\n# Works with regular values\nregular_value = 4\nprint(process_data(regular_value))  # 8\n\n# Works with reactive values\nreactive_value = Signal(5)\nprint(process_data(reactive_value))  # 10\n\n# Works with nested reactive values\nnested_value = Signal(Signal(Signal(6)))\nprint(process_data(nested_value))   # 12\n</code></pre>"}]}