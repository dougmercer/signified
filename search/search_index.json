{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Significant","text":"<p>A Python library for reactive programming with kind-of working type hints.</p>"},{"location":"#getting-started","title":"Getting started","text":"<pre><code>pip install significant\n</code></pre>"},{"location":"#why-care","title":"Why care?","text":"<p><code>significant</code> is a reactive programming library that implements two primary data structures: <code>Signal</code> and <code>Computed</code>.</p> <p>Both of these objects implement the Observer and Observable design patterns. This means that they can notify other Observers if they change, and they can subscribe to be notified if another Observable changes.</p> <p>This allows us to create a network of computation, where one value being modified can trigger other objects to update.</p> <p>This allows us to write more declarative code, like,</p> <pre><code>x = Signal(3)\nx_squared = x ** 2  # currently equal to 9\nx.value = 10  # Will immediately notify x_squared, whose value will become 100.\n</code></pre> <p>Here, <code>x_squared</code> became a reactive expression (more specifically, a <code>Computed</code> object) whose value is always equal to <code>x ** 2</code>. Neat!</p> <p><code>significant</code>'s <code>Signal</code> object effective gives us a container which stores a value, and <code>Computed</code> gives us a container to store the current value of a function. In the above example, we generated the Computed object on-the-fly using overloaded Python operators like <code>**</code>, but we could have just as easily done,</p> <pre><code>from significant import computed\n\n@computed\ndef power(x, n):\n    return x**n\n\nx_squared = power(x, 2)  # equivalent to the above\n</code></pre> <p>Together, these data structures allow us to implement a wide variety of capabilities. In particular, I wrote this library to make my to-be-released animation library easier to maintain and more fun to work with.</p> <p>Hopefully you find it useful!</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>A reactive programming library for reactive values and functions.</p> <p>Classes:</p> Name Description <code>Variable</code> <p>Abstract base class for reactive values.</p> <code>Signal</code> <p>A container for mutable reactive values.</p> <code>Computed</code> <p>A container for computed reactive values (from functions).</p> <p>Functions:</p> Name Description <code>unref</code> <p>Dereference a potentially reactive value.</p> <code>computed</code> <p>Decorator to create a Computed value from a function.</p> <code>reactive_method</code> <p>Decorator to create a reactive method.</p> <code>as_signal</code> <p>Convert a value to a Signal if it's not already a Variable.</p> <code>has_value</code> <p>Type guard to check if an object has a value of a specific type.</p> <p>Attributes:</p> Name Type Description <code>ReactiveValue</code> <code>TypeAlias</code> <p>Union of Computed and Signal types.</p> <code>HasValue</code> <code>TypeAlias</code> <p>Union of plain values, Computed, and Signal types.</p> <code>NestedValue</code> <code>TypeAlias</code> <p>Recursive type for arbitrarily nested Signals.</p>"},{"location":"api_reference/#significant.HasValue","title":"<code>HasValue: TypeAlias = T | Computed[T] | Signal[T]</code>  <code>module-attribute</code>","text":"<p>This object would return a value of type T when calling <code>unref(obj)</code>.</p> <p>This type alias represents any value that can be dereferenced, including plain values, Computed values, and Signals.</p> See Also <p>Computed: The class representing computed reactive values. Signal: The class representing mutable reactive values. unref: Function to dereference values.</p>"},{"location":"api_reference/#significant.NestedValue","title":"<code>NestedValue: TypeAlias = Union[T, '_HasValue[NestedValue[T]]']</code>  <code>module-attribute</code>","text":"<p>Insane recursive type hint to try to encode an arbitrarily nested Signals.</p> <p>E.g., <code>float | Signal[float] | Signal[Signal[float]] | Signal[Signal[Signal[float]]].</code></p>"},{"location":"api_reference/#significant.ReactiveValue","title":"<code>ReactiveValue: TypeAlias = Computed[T] | Signal[T]</code>  <code>module-attribute</code>","text":"<p>A reactive object that would return a value of type T when calling <code>unref</code><code>(obj)</code>.</p> <p>This type alias represents any reactive value, either a <code>Computed</code> or a <code>Signal</code>.</p> See Also <ul> <li><code>Computed</code>: The class representing computed reactive values.</li> <li><code>Signal</code>: The class representing mutable reactive values.</li> <li><code>unref</code>: Function to dereference values.</li> </ul>"},{"location":"api_reference/#significant.Computed","title":"<code>Computed</code>","text":"<p>               Bases: <code>Variable[T, T]</code></p> <p>A reactive value defined by a function.</p> <p>Parameters:</p> Name Type Description Default <code>compute_func</code> <code>Callable[[], T]</code> <p>The function that computes the value.</p> required <code>dependencies</code> <code>Any</code> <p>Dependencies to register.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>_f</code> <code>Callable[[], T]</code> <p>The function that computes the value.</p> <code>_value</code> <code>T</code> <p>The current computed value.</p> Source code in <code>significant.py</code> <pre><code>class Computed(Variable[T, T]):\n    \"\"\"A reactive value defined by a function.\n\n    Args:\n        compute_func: The function that computes the value.\n        dependencies: Dependencies to register.\n\n    Attributes:\n        _f (Callable[[], T]): The function that computes the value.\n        _value (T): The current computed value.\n    \"\"\"\n\n    def __init__(self, compute_func: Callable[[], T], dependencies: Any = None) -&gt; None:\n        super().__init__()\n        self._f = compute_func\n        if dependencies is not None:\n            self.register(dependencies)\n        self.update()\n\n    def update(self) -&gt; None:\n        \"\"\"Update the value by evaluating the Computed's function.\"\"\"\n        new_value = unref(self._f())\n        try:\n            change = new_value != self._value\n            if isinstance(change, np.ndarray):\n                change = change.any()\n        except AttributeError:\n            change = False\n\n        if not hasattr(self, \"_value\") or change:\n            self._value: T = new_value\n            self.notify_subscribers()\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"Get the current computed value.\n\n        Returns:\n            The current computed value.\n        \"\"\"\n        return unref(self._value)\n</code></pre>"},{"location":"api_reference/#significant.Computed.value","title":"<code>value: T</code>  <code>property</code>","text":"<p>Get the current computed value.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current computed value.</p>"},{"location":"api_reference/#significant.Computed.update","title":"<code>update()</code>","text":"<p>Update the value by evaluating the Computed's function.</p> Source code in <code>significant.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the value by evaluating the Computed's function.\"\"\"\n    new_value = unref(self._f())\n    try:\n        change = new_value != self._value\n        if isinstance(change, np.ndarray):\n            change = change.any()\n    except AttributeError:\n        change = False\n\n    if not hasattr(self, \"_value\") or change:\n        self._value: T = new_value\n        self.notify_subscribers()\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn","title":"<code>ReactiveMixIn</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Methods for easily creating reactive values.</p> Source code in <code>significant.py</code> <pre><code>class ReactiveMixIn(Generic[T]):\n    \"\"\"Methods for easily creating reactive values.\"\"\"\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"The current value of the reactive object.\"\"\"\n        ...\n\n    def __getattr__(self, name: str) -&gt; Any:\n        \"\"\"Create a Computed for retrieving an attribute from self.value.\n\n        Args:\n            name: The name of the attribute to access.\n\n        Returns:\n            A Computed object representing the attribute access.\n\n        Raises:\n            AttributeError: If the attribute doesn't exist.\n        \"\"\"\n        if name in {\"value\", \"_value\"}:\n            return super().__getattribute__(name)\n\n        if hasattr(self.value, name):\n            return Computed(lambda: getattr(self.value, name), [self])\n        else:\n            return super().__getattribute__(name)\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Create a Computed for calling self.value(*args, **kwargs).\n\n        Args:\n            *args: Positional arguments to pass to the callable value.\n            **kwargs: Keyword arguments to pass to the callable value.\n\n        Returns:\n            A Computed object representing the function call.\n\n        Raises:\n            ValueError: If the value is not callable.\n        \"\"\"\n        if not callable(self.value):\n            raise ValueError(\"Value is not callable.\")\n        return computed(self.value)(*args, **kwargs).register(self)\n\n    def __abs__(self) -&gt; Computed[T]:\n        \"\"\"Return a Computed representing the absolute value of self.\n\n        Returns:\n            A Computed object representing abs(self.value).\n        \"\"\"\n        return computed(abs)(self)\n\n    def bool(self) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing the boolean value of self.\n\n        Note:\n            `__bool__` cannot be implemented to return a non-`bool`, so it is provided as a method.\n\n        Returns:\n            A Computed object representing bool(self.value).\n        \"\"\"\n        return computed(bool)(self)\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the current value.\n\n        Note:\n            This does not return a reactive value.\n\n        Returns:\n            A string representation of self.value.\n        \"\"\"\n        return str(self.value)\n\n    @overload\n    def __round__(self, ndigits: None) -&gt; Computed[int]: ...\n    @overload\n    def __round__(self, ndigits: int) -&gt; Computed[float]: ...\n\n    def __round__(self, ndigits: int | None = None) -&gt; Computed[int] | Computed[float]:\n        \"\"\"Return a Computed representing the rounded value of self.\n\n        Args:\n            ndigits: Number of decimal places to round to.\n\n        Returns:\n            A Computed object representing round(self.value, ndigits).\n        \"\"\"\n        if ndigits is None or ndigits == 0:\n            # When ndigits is None or 0, round returns an integer\n            return cast(Computed[int], computed(round)(self, ndigits=ndigits))\n        else:\n            # Otherwise, float\n            return cast(Computed[float], computed(round)(self, ndigits=ndigits))\n\n    def __ceil__(self) -&gt; Computed[int]:\n        \"\"\"Return a Computed representing the ceiling of self.\n\n        Returns:\n            A Computed object representing math.ceil(self.value).\n        \"\"\"\n        return cast(Computed[int], computed(math.ceil)(self))\n\n    def __floor__(self) -&gt; Computed[int]:\n        \"\"\"Return a Computed representing the floor of self.\n\n        Returns:\n            A Computed object representing math.floor(self.value).\n        \"\"\"\n        return cast(Computed[int], computed(math.floor)(self))\n\n    def __invert__(self) -&gt; Computed[T]:\n        \"\"\"Return a Computed representing the bitwise inversion of self.\n\n        Returns:\n            A Computed object representing ~self.value.\n        \"\"\"\n        return computed(operator.inv)(self)\n\n    def __neg__(self) -&gt; Computed[T]:\n        \"\"\"Return a Computed representing the negation of self.\n\n        Returns:\n            A Computed object representing -self.value.\n        \"\"\"\n        return computed(operator.neg)(self)\n\n    def __pos__(self) -&gt; Computed[T]:\n        \"\"\"Return a Computed representing the positive of self.\n\n        Returns:\n            A Computed object representing +self.value.\n        \"\"\"\n        return computed(operator.pos)(self)\n\n    def __trunc__(self) -&gt; Computed[T]:\n        \"\"\"Return a Computed representing the truncated value of self.\n\n        Returns:\n            A Computed object representing math.trunc(self.value).\n        \"\"\"\n        return computed(math.trunc)(self)\n\n    def __add__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing the sum of self and other.\n\n        Args:\n            other: The value to add.\n\n        Returns:\n            A Computed object representing self.value + other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.add\n        return computed(f)(self, other)\n\n    def __and__(self, other: HasValue[Y]) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing the logical AND of self and other.\n\n        Args:\n            other: The value to AND with.\n\n        Returns:\n            A Computed object representing self.value and other.value.\n        \"\"\"\n        return computed(operator.and_)(self, other)\n\n    def __contains__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether other is in self.\n\n        Args:\n            other: The value to check for containment.\n\n        Returns:\n            A Computed object representing other in self.value.\n        \"\"\"\n        return computed(operator.contains)(self, other)\n\n    def __divmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n        \"\"\"Return a Computed representing the divmod of self and other.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A Computed object representing divmod(self.value, other).\n        \"\"\"\n        return cast(Computed[tuple[float, float]], computed(divmod)(self, other))\n\n    def is_not(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether self is not other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value is not other.\n        \"\"\"\n        return computed(operator.is_not)(self, other)\n\n    def eq(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether self equals other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value == other.\n        \"\"\"\n        return computed(operator.eq)(self, other)\n\n    def __floordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing the floor division of self by other.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A Computed object representing self.value // other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.floordiv\n        return computed(f)(self, other)\n\n    def __ge__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether self is greater than or equal to other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value &gt;= other.\n        \"\"\"\n        return computed(operator.ge)(self, other)\n\n    def __gt__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether self is greater than other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value &gt; other.\n        \"\"\"\n        return computed(operator.gt)(self, other)\n\n    def __le__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether self is less than or equal to other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value &lt;= other.\n        \"\"\"\n        return computed(operator.le)(self, other)\n\n    def __lt__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing whether self is less than other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value &lt; other.\n        \"\"\"\n        return computed(operator.lt)(self, other)\n\n    def __lshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing self left-shifted by other.\n\n        Args:\n            other: The number of positions to shift.\n\n        Returns:\n            A Computed object representing self.value &lt;&lt; other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.lshift\n        return computed(f)(self, other)\n\n    def __matmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing the matrix multiplication of self and other.\n\n        Args:\n            other: The value to multiply with.\n\n        Returns:\n            A Computed object representing self.value @ other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.matmul\n        return computed(f)(self, other)\n\n    def __mod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing self modulo other.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A Computed object representing self.value % other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.mod\n        return computed(f)(self, other)\n\n    def __mul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing the product of self and other.\n\n        Args:\n            other: The value to multiply with.\n\n        Returns:\n            A Computed object representing self.value * other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.mul\n        return computed(f)(self, other)\n\n    def __ne__(self, other: Any) -&gt; Computed[bool]:  # type: ignore[override]\n        \"\"\"Return a Computed representing whether self is not equal to other.\n\n        Args:\n            other: The value to compare against.\n\n        Returns:\n            A Computed object representing self.value != other.\n        \"\"\"\n        return computed(operator.ne)(self, other)\n\n    def __or__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing the logical OR of self and other.\n\n        Args:\n            other: The value to OR with.\n\n        Returns:\n            A Computed object representing self.value or other.value.\n        \"\"\"\n        return computed(operator.or_)(self, other)\n\n    def __rshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing self right-shifted by other.\n\n        Args:\n            other: The number of positions to shift.\n\n        Returns:\n            A Computed object representing self.value &gt;&gt; other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.rshift\n        return computed(f)(self, other)\n\n    def __pow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing self raised to the power of other.\n\n        Args:\n            other: The exponent.\n\n        Returns:\n            A Computed object representing self.value ** other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.pow\n        return computed(f)(self, other)\n\n    def __sub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing the difference of self and other.\n\n        Args:\n            other: The value to subtract.\n\n        Returns:\n            A Computed object representing self.value - other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.sub\n        return computed(f)(self, other)\n\n    def __truediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        \"\"\"Return a Computed representing self divided by other.\n\n        Args:\n            other: The value to use as the divisor.\n\n        Returns:\n            A Computed object representing self.value / other.value.\n        \"\"\"\n        f: Callable[[T, Y], T | Y] = operator.truediv\n        return computed(f)(self, other)\n\n    def __xor__(self, other: Any) -&gt; Computed[bool]:\n        \"\"\"Return a Computed representing the logical XOR of self and other.\n\n        Args:\n            other: The value to XOR with.\n\n        Returns:\n            A Computed object representing self.value ^ other.value.\n        \"\"\"\n        return computed(operator.xor)(self, other)\n\n    def __radd__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.add\n        return computed(f)(other, self)\n\n    def __rand__(self, other: Any) -&gt; Computed[bool]:\n        return computed(operator.and_)(other, self)\n\n    def __rdivmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n        return cast(Computed[tuple[float, float]], computed(divmod)(other, self))\n\n    def __rfloordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.floordiv\n        return computed(f)(other, self)\n\n    def __rmod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.mod\n        return computed(f)(other, self)\n\n    def __rmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.mul\n        return computed(f)(other, self)\n\n    def __ror__(self, other: Any) -&gt; Computed[bool]:\n        return computed(operator.or_)(other, self)\n\n    def __rpow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.pow\n        return computed(f)(other, self)\n\n    def __rsub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.sub\n        return computed(f)(other, self)\n\n    def __rtruediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n        f: Callable[[Y, T], T | Y] = operator.truediv\n        return computed(f)(other, self)\n\n    def __rxor__(self, other: Any) -&gt; Computed[bool]:\n        return computed(operator.xor)(other, self)\n\n    def __getitem__(self, other: Any) -&gt; Computed[Any]:\n        \"\"\"Return a Computed representing the item or slice of self.\n\n        Args:\n            other: The index or slice to retrieve.\n\n        Returns:\n            A Computed object representing self.value[other].\n        \"\"\"\n        return computed(operator.getitem)(self, other)\n\n    def where(self, a: HasValue[A], b: HasValue[B]) -&gt; Computed[A | B]:\n        \"\"\"Return a Computed representing a if self is true, else b.\n\n        Args:\n            a: The value to return if self is true.\n            b: The value to return if self is false.\n\n        Returns:\n            A Computed object representing a if self.value else b.\n        \"\"\"\n\n        @computed\n        def ternary(a: A, b: B, self: Any) -&gt; A | B:\n            return a if self else b\n\n        return ternary(a, b, self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.value","title":"<code>value: T</code>  <code>property</code>","text":"<p>The current value of the reactive object.</p>"},{"location":"api_reference/#significant.ReactiveMixIn.__abs__","title":"<code>__abs__()</code>","text":"<p>Return a Computed representing the absolute value of self.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A Computed object representing abs(self.value).</p> Source code in <code>significant.py</code> <pre><code>def __abs__(self) -&gt; Computed[T]:\n    \"\"\"Return a Computed representing the absolute value of self.\n\n    Returns:\n        A Computed object representing abs(self.value).\n    \"\"\"\n    return computed(abs)(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__add__","title":"<code>__add__(other)</code>","text":"<p>Return a Computed representing the sum of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to add.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value + other.value.</p> Source code in <code>significant.py</code> <pre><code>def __add__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing the sum of self and other.\n\n    Args:\n        other: The value to add.\n\n    Returns:\n        A Computed object representing self.value + other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.add\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__and__","title":"<code>__and__(other)</code>","text":"<p>Return a Computed representing the logical AND of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to AND with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value and other.value.</p> Source code in <code>significant.py</code> <pre><code>def __and__(self, other: HasValue[Y]) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing the logical AND of self and other.\n\n    Args:\n        other: The value to AND with.\n\n    Returns:\n        A Computed object representing self.value and other.value.\n    \"\"\"\n    return computed(operator.and_)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Create a Computed for calling self.value(*args, **kwargs).</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callable value.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callable value.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>A Computed object representing the function call.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the value is not callable.</p> Source code in <code>significant.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Create a Computed for calling self.value(*args, **kwargs).\n\n    Args:\n        *args: Positional arguments to pass to the callable value.\n        **kwargs: Keyword arguments to pass to the callable value.\n\n    Returns:\n        A Computed object representing the function call.\n\n    Raises:\n        ValueError: If the value is not callable.\n    \"\"\"\n    if not callable(self.value):\n        raise ValueError(\"Value is not callable.\")\n    return computed(self.value)(*args, **kwargs).register(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__ceil__","title":"<code>__ceil__()</code>","text":"<p>Return a Computed representing the ceiling of self.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A Computed object representing math.ceil(self.value).</p> Source code in <code>significant.py</code> <pre><code>def __ceil__(self) -&gt; Computed[int]:\n    \"\"\"Return a Computed representing the ceiling of self.\n\n    Returns:\n        A Computed object representing math.ceil(self.value).\n    \"\"\"\n    return cast(Computed[int], computed(math.ceil)(self))\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__contains__","title":"<code>__contains__(other)</code>","text":"<p>Return a Computed representing whether other is in self.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to check for containment.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing other in self.value.</p> Source code in <code>significant.py</code> <pre><code>def __contains__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether other is in self.\n\n    Args:\n        other: The value to check for containment.\n\n    Returns:\n        A Computed object representing other in self.value.\n    \"\"\"\n    return computed(operator.contains)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__divmod__","title":"<code>__divmod__(other)</code>","text":"<p>Return a Computed representing the divmod of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[tuple[float, float]]</code> <p>A Computed object representing divmod(self.value, other).</p> Source code in <code>significant.py</code> <pre><code>def __divmod__(self, other: Any) -&gt; Computed[tuple[float, float]]:\n    \"\"\"Return a Computed representing the divmod of self and other.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A Computed object representing divmod(self.value, other).\n    \"\"\"\n    return cast(Computed[tuple[float, float]], computed(divmod)(self, other))\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__floor__","title":"<code>__floor__()</code>","text":"<p>Return a Computed representing the floor of self.</p> <p>Returns:</p> Type Description <code>Computed[int]</code> <p>A Computed object representing math.floor(self.value).</p> Source code in <code>significant.py</code> <pre><code>def __floor__(self) -&gt; Computed[int]:\n    \"\"\"Return a Computed representing the floor of self.\n\n    Returns:\n        A Computed object representing math.floor(self.value).\n    \"\"\"\n    return cast(Computed[int], computed(math.floor)(self))\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__floordiv__","title":"<code>__floordiv__(other)</code>","text":"<p>Return a Computed representing the floor division of self by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value // other.value.</p> Source code in <code>significant.py</code> <pre><code>def __floordiv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing the floor division of self by other.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A Computed object representing self.value // other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.floordiv\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Return a Computed representing whether self is greater than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value &gt;= other.</p> Source code in <code>significant.py</code> <pre><code>def __ge__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether self is greater than or equal to other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value &gt;= other.\n    \"\"\"\n    return computed(operator.ge)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Create a Computed for retrieving an attribute from self.value.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>A Computed object representing the attribute access.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute doesn't exist.</p> Source code in <code>significant.py</code> <pre><code>def __getattr__(self, name: str) -&gt; Any:\n    \"\"\"Create a Computed for retrieving an attribute from self.value.\n\n    Args:\n        name: The name of the attribute to access.\n\n    Returns:\n        A Computed object representing the attribute access.\n\n    Raises:\n        AttributeError: If the attribute doesn't exist.\n    \"\"\"\n    if name in {\"value\", \"_value\"}:\n        return super().__getattribute__(name)\n\n    if hasattr(self.value, name):\n        return Computed(lambda: getattr(self.value, name), [self])\n    else:\n        return super().__getattribute__(name)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__getitem__","title":"<code>__getitem__(other)</code>","text":"<p>Return a Computed representing the item or slice of self.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The index or slice to retrieve.</p> required <p>Returns:</p> Type Description <code>Computed[Any]</code> <p>A Computed object representing self.value[other].</p> Source code in <code>significant.py</code> <pre><code>def __getitem__(self, other: Any) -&gt; Computed[Any]:\n    \"\"\"Return a Computed representing the item or slice of self.\n\n    Args:\n        other: The index or slice to retrieve.\n\n    Returns:\n        A Computed object representing self.value[other].\n    \"\"\"\n    return computed(operator.getitem)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Return a Computed representing whether self is greater than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value &gt; other.</p> Source code in <code>significant.py</code> <pre><code>def __gt__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether self is greater than other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value &gt; other.\n    \"\"\"\n    return computed(operator.gt)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__invert__","title":"<code>__invert__()</code>","text":"<p>Return a Computed representing the bitwise inversion of self.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A Computed object representing ~self.value.</p> Source code in <code>significant.py</code> <pre><code>def __invert__(self) -&gt; Computed[T]:\n    \"\"\"Return a Computed representing the bitwise inversion of self.\n\n    Returns:\n        A Computed object representing ~self.value.\n    \"\"\"\n    return computed(operator.inv)(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__le__","title":"<code>__le__(other)</code>","text":"<p>Return a Computed representing whether self is less than or equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value &lt;= other.</p> Source code in <code>significant.py</code> <pre><code>def __le__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether self is less than or equal to other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value &lt;= other.\n    \"\"\"\n    return computed(operator.le)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__lshift__","title":"<code>__lshift__(other)</code>","text":"<p>Return a Computed representing self left-shifted by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value &lt;&lt; other.value.</p> Source code in <code>significant.py</code> <pre><code>def __lshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing self left-shifted by other.\n\n    Args:\n        other: The number of positions to shift.\n\n    Returns:\n        A Computed object representing self.value &lt;&lt; other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.lshift\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return a Computed representing whether self is less than other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value &lt; other.</p> Source code in <code>significant.py</code> <pre><code>def __lt__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether self is less than other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value &lt; other.\n    \"\"\"\n    return computed(operator.lt)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__matmul__","title":"<code>__matmul__(other)</code>","text":"<p>Return a Computed representing the matrix multiplication of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value @ other.value.</p> Source code in <code>significant.py</code> <pre><code>def __matmul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing the matrix multiplication of self and other.\n\n    Args:\n        other: The value to multiply with.\n\n    Returns:\n        A Computed object representing self.value @ other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.matmul\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__mod__","title":"<code>__mod__(other)</code>","text":"<p>Return a Computed representing self modulo other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value % other.value.</p> Source code in <code>significant.py</code> <pre><code>def __mod__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing self modulo other.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A Computed object representing self.value % other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.mod\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Return a Computed representing the product of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to multiply with.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value * other.value.</p> Source code in <code>significant.py</code> <pre><code>def __mul__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing the product of self and other.\n\n    Args:\n        other: The value to multiply with.\n\n    Returns:\n        A Computed object representing self.value * other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.mul\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Return a Computed representing whether self is not equal to other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value != other.</p> Source code in <code>significant.py</code> <pre><code>def __ne__(self, other: Any) -&gt; Computed[bool]:  # type: ignore[override]\n    \"\"\"Return a Computed representing whether self is not equal to other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value != other.\n    \"\"\"\n    return computed(operator.ne)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__neg__","title":"<code>__neg__()</code>","text":"<p>Return a Computed representing the negation of self.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A Computed object representing -self.value.</p> Source code in <code>significant.py</code> <pre><code>def __neg__(self) -&gt; Computed[T]:\n    \"\"\"Return a Computed representing the negation of self.\n\n    Returns:\n        A Computed object representing -self.value.\n    \"\"\"\n    return computed(operator.neg)(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__or__","title":"<code>__or__(other)</code>","text":"<p>Return a Computed representing the logical OR of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to OR with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value or other.value.</p> Source code in <code>significant.py</code> <pre><code>def __or__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing the logical OR of self and other.\n\n    Args:\n        other: The value to OR with.\n\n    Returns:\n        A Computed object representing self.value or other.value.\n    \"\"\"\n    return computed(operator.or_)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__pos__","title":"<code>__pos__()</code>","text":"<p>Return a Computed representing the positive of self.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A Computed object representing +self.value.</p> Source code in <code>significant.py</code> <pre><code>def __pos__(self) -&gt; Computed[T]:\n    \"\"\"Return a Computed representing the positive of self.\n\n    Returns:\n        A Computed object representing +self.value.\n    \"\"\"\n    return computed(operator.pos)(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__pow__","title":"<code>__pow__(other)</code>","text":"<p>Return a Computed representing self raised to the power of other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The exponent.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value ** other.value.</p> Source code in <code>significant.py</code> <pre><code>def __pow__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing self raised to the power of other.\n\n    Args:\n        other: The exponent.\n\n    Returns:\n        A Computed object representing self.value ** other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.pow\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__round__","title":"<code>__round__(ndigits=None)</code>","text":"<p>Return a Computed representing the rounded value of self.</p> <p>Parameters:</p> Name Type Description Default <code>ndigits</code> <code>int | None</code> <p>Number of decimal places to round to.</p> <code>None</code> <p>Returns:</p> Type Description <code>Computed[int] | Computed[float]</code> <p>A Computed object representing round(self.value, ndigits).</p> Source code in <code>significant.py</code> <pre><code>def __round__(self, ndigits: int | None = None) -&gt; Computed[int] | Computed[float]:\n    \"\"\"Return a Computed representing the rounded value of self.\n\n    Args:\n        ndigits: Number of decimal places to round to.\n\n    Returns:\n        A Computed object representing round(self.value, ndigits).\n    \"\"\"\n    if ndigits is None or ndigits == 0:\n        # When ndigits is None or 0, round returns an integer\n        return cast(Computed[int], computed(round)(self, ndigits=ndigits))\n    else:\n        # Otherwise, float\n        return cast(Computed[float], computed(round)(self, ndigits=ndigits))\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__rshift__","title":"<code>__rshift__(other)</code>","text":"<p>Return a Computed representing self right-shifted by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The number of positions to shift.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value &gt;&gt; other.value.</p> Source code in <code>significant.py</code> <pre><code>def __rshift__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing self right-shifted by other.\n\n    Args:\n        other: The number of positions to shift.\n\n    Returns:\n        A Computed object representing self.value &gt;&gt; other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.rshift\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the current value.</p> Note <p>This does not return a reactive value.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of self.value.</p> Source code in <code>significant.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the current value.\n\n    Note:\n        This does not return a reactive value.\n\n    Returns:\n        A string representation of self.value.\n    \"\"\"\n    return str(self.value)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Return a Computed representing the difference of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to subtract.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value - other.value.</p> Source code in <code>significant.py</code> <pre><code>def __sub__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing the difference of self and other.\n\n    Args:\n        other: The value to subtract.\n\n    Returns:\n        A Computed object representing self.value - other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.sub\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Return a Computed representing self divided by other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HasValue[Y]</code> <p>The value to use as the divisor.</p> required <p>Returns:</p> Type Description <code>Computed[T | Y]</code> <p>A Computed object representing self.value / other.value.</p> Source code in <code>significant.py</code> <pre><code>def __truediv__(self, other: HasValue[Y]) -&gt; Computed[T | Y]:\n    \"\"\"Return a Computed representing self divided by other.\n\n    Args:\n        other: The value to use as the divisor.\n\n    Returns:\n        A Computed object representing self.value / other.value.\n    \"\"\"\n    f: Callable[[T, Y], T | Y] = operator.truediv\n    return computed(f)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__trunc__","title":"<code>__trunc__()</code>","text":"<p>Return a Computed representing the truncated value of self.</p> <p>Returns:</p> Type Description <code>Computed[T]</code> <p>A Computed object representing math.trunc(self.value).</p> Source code in <code>significant.py</code> <pre><code>def __trunc__(self) -&gt; Computed[T]:\n    \"\"\"Return a Computed representing the truncated value of self.\n\n    Returns:\n        A Computed object representing math.trunc(self.value).\n    \"\"\"\n    return computed(math.trunc)(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.__xor__","title":"<code>__xor__(other)</code>","text":"<p>Return a Computed representing the logical XOR of self and other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to XOR with.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value ^ other.value.</p> Source code in <code>significant.py</code> <pre><code>def __xor__(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing the logical XOR of self and other.\n\n    Args:\n        other: The value to XOR with.\n\n    Returns:\n        A Computed object representing self.value ^ other.value.\n    \"\"\"\n    return computed(operator.xor)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.bool","title":"<code>bool()</code>","text":"<p>Return a Computed representing the boolean value of self.</p> Note <p><code>__bool__</code> cannot be implemented to return a non-<code>bool</code>, so it is provided as a method.</p> <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing bool(self.value).</p> Source code in <code>significant.py</code> <pre><code>def bool(self) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing the boolean value of self.\n\n    Note:\n        `__bool__` cannot be implemented to return a non-`bool`, so it is provided as a method.\n\n    Returns:\n        A Computed object representing bool(self.value).\n    \"\"\"\n    return computed(bool)(self)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.eq","title":"<code>eq(other)</code>","text":"<p>Return a Computed representing whether self equals other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value == other.</p> Source code in <code>significant.py</code> <pre><code>def eq(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether self equals other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value == other.\n    \"\"\"\n    return computed(operator.eq)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.is_not","title":"<code>is_not(other)</code>","text":"<p>Return a Computed representing whether self is not other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The value to compare against.</p> required <p>Returns:</p> Type Description <code>Computed[bool]</code> <p>A Computed object representing self.value is not other.</p> Source code in <code>significant.py</code> <pre><code>def is_not(self, other: Any) -&gt; Computed[bool]:\n    \"\"\"Return a Computed representing whether self is not other.\n\n    Args:\n        other: The value to compare against.\n\n    Returns:\n        A Computed object representing self.value is not other.\n    \"\"\"\n    return computed(operator.is_not)(self, other)\n</code></pre>"},{"location":"api_reference/#significant.ReactiveMixIn.where","title":"<code>where(a, b)</code>","text":"<p>Return a Computed representing a if self is true, else b.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>HasValue[A]</code> <p>The value to return if self is true.</p> required <code>b</code> <code>HasValue[B]</code> <p>The value to return if self is false.</p> required <p>Returns:</p> Type Description <code>Computed[A | B]</code> <p>A Computed object representing a if self.value else b.</p> Source code in <code>significant.py</code> <pre><code>def where(self, a: HasValue[A], b: HasValue[B]) -&gt; Computed[A | B]:\n    \"\"\"Return a Computed representing a if self is true, else b.\n\n    Args:\n        a: The value to return if self is true.\n        b: The value to return if self is false.\n\n    Returns:\n        A Computed object representing a if self.value else b.\n    \"\"\"\n\n    @computed\n    def ternary(a: A, b: B, self: Any) -&gt; A | B:\n        return a if self else b\n\n    return ternary(a, b, self)\n</code></pre>"},{"location":"api_reference/#significant.Signal","title":"<code>Signal</code>","text":"<p>               Bases: <code>Variable[NestedValue[T], T]</code></p> <p>A container that holds a reactive value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>NestedValue[T]</code> <p>The initial value of the signal, which can be a nested structure.</p> required <p>Attributes:</p> Name Type Description <code>_value</code> <code>NestedValue[T]</code> <p>The current value of the signal.</p> Source code in <code>significant.py</code> <pre><code>class Signal(Variable[NestedValue[T], T]):\n    \"\"\"A container that holds a reactive value.\n\n    Args:\n        value: The initial value of the signal, which can be a nested structure.\n\n    Attributes:\n        _value (NestedValue[T]): The current value of the signal.\n    \"\"\"\n\n    def __init__(self, value: NestedValue[T]) -&gt; None:\n        super().__init__()\n        self._value: T = cast(T, value)\n        self.register(value)\n\n    @property\n    def value(self) -&gt; T:\n        \"\"\"Get the current value of the signal.\n\n        Returns:\n            The current value, after resolving any nested reactive variables.\n        \"\"\"\n        return unref(self._value)\n\n    @value.setter\n    def value(self, new_value: HasValue[T]) -&gt; None:\n        \"\"\"Set a new value for the signal, notifying subscribers if the value changes.\n\n        Args:\n            new_value: The new value, which can also be a reactive variable.\n        \"\"\"\n        if new_value != self._value:\n            self._value = cast(T, new_value)\n            self.register(new_value)\n            self.notify_subscribers()\n\n    @contextmanager\n    def at(self, value: T) -&gt; Generator[None, None, None]:\n        \"\"\"Temporarily set the signal to a given value within a context.\n\n        Args:\n            value: The temporary value to set.\n\n        Yields:\n            None\n        \"\"\"\n        before = self.value\n        try:\n            before = self.value\n            self.value = value\n            yield\n        finally:\n            self.value = before\n\n    def update(self) -&gt; None:\n        \"\"\"Update the signal and notify subscribers.\"\"\"\n        self.notify_subscribers()\n</code></pre>"},{"location":"api_reference/#significant.Signal.value","title":"<code>value: T</code>  <code>property</code> <code>writable</code>","text":"<p>Get the current value of the signal.</p> <p>Returns:</p> Type Description <code>T</code> <p>The current value, after resolving any nested reactive variables.</p>"},{"location":"api_reference/#significant.Signal.at","title":"<code>at(value)</code>","text":"<p>Temporarily set the signal to a given value within a context.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The temporary value to set.</p> required <p>Yields:</p> Type Description <code>None</code> <p>None</p> Source code in <code>significant.py</code> <pre><code>@contextmanager\ndef at(self, value: T) -&gt; Generator[None, None, None]:\n    \"\"\"Temporarily set the signal to a given value within a context.\n\n    Args:\n        value: The temporary value to set.\n\n    Yields:\n        None\n    \"\"\"\n    before = self.value\n    try:\n        before = self.value\n        self.value = value\n        yield\n    finally:\n        self.value = before\n</code></pre>"},{"location":"api_reference/#significant.Signal.update","title":"<code>update()</code>","text":"<p>Update the signal and notify subscribers.</p> Source code in <code>significant.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the signal and notify subscribers.\"\"\"\n    self.notify_subscribers()\n</code></pre>"},{"location":"api_reference/#significant.Variable","title":"<code>Variable</code>","text":"<p>               Bases: <code>_HasValue[Y]</code>, <code>ReactiveMixIn[T]</code></p> <p>An abstract base class for reactive values.</p> <p>This class implements both the observer and observable pattern. Subclasses should implement the <code>update</code> method.</p> <p>Attributes:</p> Name Type Description <code>_observers</code> <code>list[Observer]</code> <p>List of observers subscribed to this variable.</p> Source code in <code>significant.py</code> <pre><code>class Variable(_HasValue[Y], ReactiveMixIn[T]):  # type: ignore[misc]\n    \"\"\"An abstract base class for reactive values.\n\n    This class implements both the observer and observable pattern. Subclasses should\n    implement the `update` method.\n\n    Attributes:\n        _observers (list[Observer]): List of observers subscribed to this variable.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the variable.\"\"\"\n        self._observers: list[Observer] = []\n\n    def subscribe(self, observer: Observer) -&gt; None:\n        \"\"\"Subscribe an observer to this variable.\n\n        Args:\n            observer: The observer to subscribe.\n        \"\"\"\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def unsubscribe(self, observer: Observer) -&gt; None:\n        \"\"\"Unsubscribe an observer from this variable.\n\n        Args:\n            observer: The observer to unsubscribe.\n        \"\"\"\n        if observer in self._observers:\n            self._observers.remove(observer)\n\n    def notify_subscribers(self) -&gt; None:\n        \"\"\"Notify all subscribers by calling their update method.\"\"\"\n        for subsciber in self._observers:\n            subsciber.update()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Represent the object in a way that shows the inner value.\"\"\"\n        return f\"&lt;{self.value}&gt;\"\n\n    def update(self) -&gt; None:\n        \"\"\"Update method to be overridden by subclasses.\n\n        Raises:\n            NotImplementedError: If not overridden by a subclass.\n        \"\"\"\n        raise NotImplementedError(\"Update method should be overridden by subclasses\")\n\n    def register_one(self, item: Any) -&gt; Self:\n        \"\"\"Subscribe self to item if item is a Subject and not self.\n\n        Args:\n            item: The item to potentially subscribe to.\n\n        Returns:\n            The instance itself.\n        \"\"\"\n        if isinstance(item, Variable) and item is not self:\n            item.subscribe(self)\n        return self\n\n    def register(self, item: Any) -&gt; Self:\n        \"\"\"Subscribe self to all items.\n\n        Args:\n            item: The item or iterable of items to potentially subscribe to.\n\n        Returns:\n            The instance itself.\n        \"\"\"\n        if not isinstance(item, Iterable) or isinstance(item, str):\n            self.register_one(item)\n        else:\n            for item_ in item:\n                self.register_one(item_)\n        return self\n\n    def _ipython_display_(self) -&gt; None:\n        handle = display(self.value, display_id=True)\n        assert handle is not None\n        self.subscribe(IPythonObserver(self, handle))\n</code></pre>"},{"location":"api_reference/#significant.Variable.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the variable.</p> Source code in <code>significant.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the variable.\"\"\"\n    self._observers: list[Observer] = []\n</code></pre>"},{"location":"api_reference/#significant.Variable.__repr__","title":"<code>__repr__()</code>","text":"<p>Represent the object in a way that shows the inner value.</p> Source code in <code>significant.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Represent the object in a way that shows the inner value.\"\"\"\n    return f\"&lt;{self.value}&gt;\"\n</code></pre>"},{"location":"api_reference/#significant.Variable.notify_subscribers","title":"<code>notify_subscribers()</code>","text":"<p>Notify all subscribers by calling their update method.</p> Source code in <code>significant.py</code> <pre><code>def notify_subscribers(self) -&gt; None:\n    \"\"\"Notify all subscribers by calling their update method.\"\"\"\n    for subsciber in self._observers:\n        subsciber.update()\n</code></pre>"},{"location":"api_reference/#significant.Variable.register","title":"<code>register(item)</code>","text":"<p>Subscribe self to all items.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item or iterable of items to potentially subscribe to.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instance itself.</p> Source code in <code>significant.py</code> <pre><code>def register(self, item: Any) -&gt; Self:\n    \"\"\"Subscribe self to all items.\n\n    Args:\n        item: The item or iterable of items to potentially subscribe to.\n\n    Returns:\n        The instance itself.\n    \"\"\"\n    if not isinstance(item, Iterable) or isinstance(item, str):\n        self.register_one(item)\n    else:\n        for item_ in item:\n            self.register_one(item_)\n    return self\n</code></pre>"},{"location":"api_reference/#significant.Variable.register_one","title":"<code>register_one(item)</code>","text":"<p>Subscribe self to item if item is a Subject and not self.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>The item to potentially subscribe to.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The instance itself.</p> Source code in <code>significant.py</code> <pre><code>def register_one(self, item: Any) -&gt; Self:\n    \"\"\"Subscribe self to item if item is a Subject and not self.\n\n    Args:\n        item: The item to potentially subscribe to.\n\n    Returns:\n        The instance itself.\n    \"\"\"\n    if isinstance(item, Variable) and item is not self:\n        item.subscribe(self)\n    return self\n</code></pre>"},{"location":"api_reference/#significant.Variable.subscribe","title":"<code>subscribe(observer)</code>","text":"<p>Subscribe an observer to this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to subscribe.</p> required Source code in <code>significant.py</code> <pre><code>def subscribe(self, observer: Observer) -&gt; None:\n    \"\"\"Subscribe an observer to this variable.\n\n    Args:\n        observer: The observer to subscribe.\n    \"\"\"\n    if observer not in self._observers:\n        self._observers.append(observer)\n</code></pre>"},{"location":"api_reference/#significant.Variable.unsubscribe","title":"<code>unsubscribe(observer)</code>","text":"<p>Unsubscribe an observer from this variable.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>Observer</code> <p>The observer to unsubscribe.</p> required Source code in <code>significant.py</code> <pre><code>def unsubscribe(self, observer: Observer) -&gt; None:\n    \"\"\"Unsubscribe an observer from this variable.\n\n    Args:\n        observer: The observer to unsubscribe.\n    \"\"\"\n    if observer in self._observers:\n        self._observers.remove(observer)\n</code></pre>"},{"location":"api_reference/#significant.Variable.update","title":"<code>update()</code>","text":"<p>Update method to be overridden by subclasses.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not overridden by a subclass.</p> Source code in <code>significant.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update method to be overridden by subclasses.\n\n    Raises:\n        NotImplementedError: If not overridden by a subclass.\n    \"\"\"\n    raise NotImplementedError(\"Update method should be overridden by subclasses\")\n</code></pre>"},{"location":"api_reference/#significant.as_signal","title":"<code>as_signal(val)</code>","text":"<p>Convert a value to a Signal if it's not already a Variable.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>HasValue[T]</code> <p>The value to convert.</p> required <p>Returns:</p> Type Description <code>Signal[T]</code> <p>The value as a Signal.</p> Source code in <code>significant.py</code> <pre><code>def as_signal(val: HasValue[T]) -&gt; Signal[T]:\n    \"\"\"Convert a value to a Signal if it's not already a Variable.\n\n    Args:\n        val: The value to convert.\n\n    Returns:\n        The value as a Signal.\n    \"\"\"\n    return cast(Signal[T], val) if isinstance(val, Variable) else Signal(val)\n</code></pre>"},{"location":"api_reference/#significant.computed","title":"<code>computed(func)</code>","text":"<p>Decorate the function to return a Computed value.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>The function to compute the value.</p> required <p>Returns:</p> Type Description <code>Callable[..., Computed[R]]</code> <p>A function that returns a Computed value.</p> Source code in <code>significant.py</code> <pre><code>def computed(func: Callable[..., R]) -&gt; Callable[..., Computed[R]]:\n    \"\"\"Decorate the function to return a Computed value.\n\n    Args:\n        func: The function to compute the value.\n\n    Returns:\n        A function that returns a Computed value.\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Computed[R]:\n        dependencies = [arg for arg in args if isinstance(arg, Variable)]\n        dependencies.extend(value for value in kwargs.values() if isinstance(value, Variable))\n\n        def compute_func() -&gt; R:\n            resolved_args = tuple(unref(arg) for arg in args)\n            resolved_kwargs = {key: unref(value) for key, value in kwargs.items()}\n            return func(*resolved_args, **resolved_kwargs)\n\n        return Computed(compute_func, dependencies)\n\n    return wrapper\n</code></pre>"},{"location":"api_reference/#significant.has_value","title":"<code>has_value(obj, type_)</code>","text":"<p>Check if an object has a value of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <code>type_</code> <code>type[T]</code> <p>The type to check against.</p> required <p>Returns:</p> Type Description <code>TypeGuard[HasValue[T]]</code> <p>True if the object has a value of the specified type.</p> Source code in <code>significant.py</code> <pre><code>def has_value(obj: Any, type_: type[T]) -&gt; TypeGuard[HasValue[T]]:\n    \"\"\"Check if an object has a value of a specific type.\n\n    Args:\n        obj: The object to check.\n        type_: The type to check against.\n\n    Returns:\n        True if the object has a value of the specified type.\n    \"\"\"\n    return isinstance(unref(obj), type_)\n</code></pre>"},{"location":"api_reference/#significant.reactive_method","title":"<code>reactive_method(*dep_names)</code>","text":"<p>Decorate the method to return a Computed value.</p> <p>Parameters:</p> Name Type Description Default <code>*dep_names</code> <code>str</code> <p>Names of object attributes to track as dependencies.</p> <code>()</code> <p>Returns:</p> Type Description <code>Callable[[Callable[..., T]], Callable[..., Computed[T]]]</code> <p>A decorator function.</p> Source code in <code>significant.py</code> <pre><code>def reactive_method(*dep_names: str) -&gt; Callable[[Callable[..., T]], Callable[..., Computed[T]]]:\n    \"\"\"Decorate the method to return a Computed value.\n\n    Args:\n        *dep_names: Names of object attributes to track as dependencies.\n\n    Returns:\n        A decorator function.\n    \"\"\"\n\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., Computed[T]]:\n        @wraps(func)\n        def wrapper(self: Any, *args: Any, **kwargs: Any) -&gt; Computed[T]:\n            # Collect dependencies from the object\n            dependencies = [getattr(self, name) for name in dep_names if hasattr(self, name)]\n            dependencies.extend(arg for arg in args if isinstance(arg, Variable))\n            dependencies.extend(value for value in kwargs.values() if isinstance(value, Variable))\n            return Computed(lambda: func(self, *args, **kwargs), dependencies)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api_reference/#significant.unref","title":"<code>unref(value)</code>","text":"<p>Dereference a value, resolving any nested reactive variables.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>HasValue[T]</code> <p>The value to dereference.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The dereferenced value.</p> Source code in <code>significant.py</code> <pre><code>def unref(value: HasValue[T]) -&gt; T:\n    \"\"\"Dereference a value, resolving any nested reactive variables.\n\n    Args:\n        value: The value to dereference.\n\n    Returns:\n        The dereferenced value.\n    \"\"\"\n    while isinstance(value, Variable):\n        value = value._value\n    return cast(T, value)\n</code></pre>"},{"location":"changes/","title":"Change Log","text":""},{"location":"changes/#010","title":"0.1.0","text":"<p>Initial release.</p>"},{"location":"usage/","title":"Usage Examples","text":""},{"location":"usage/#simple-arithmetic","title":"Simple Arithmetic","text":"<pre><code>from significant import Signal\n\na = Signal(3)\nb = Signal(4)\n\nc = (a ** 2 + b ** 2) ** 0.5\n\nassert c.value == 5\n\na.value = 5\nb.value = 12\n\nassert c.value == 13\n</code></pre>"},{"location":"usage/#a-computed-function","title":"A Computed Function","text":"<pre><code>from significant import Signal, computed\n\na = Signal(3)\n\n@computed\ndef pow(x: int, n: int) -&gt; int:\n    return x ** n\n\na_squared = pow(a, 2)\n\nassert a_squared.value == 9\n\na.value = 5\n\nassert a_squared.value == 25\n</code></pre>"}]}